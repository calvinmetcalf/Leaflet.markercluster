{"ts":1361188225590,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var polygon = function(coordinates) {\n\n  coordinates.area = function() {\n    var i = 0,\n        n = coordinates.length,\n        area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];\n    while (++i < n) {\n      area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];\n    }\n    return area * .5;\n  };\n\n  coordinates.centroid = function(k) {\n    var i = -1,\n        n = coordinates.length,\n        x = 0,\n        y = 0,\n        a,\n        b = coordinates[n - 1],\n        c;\n    if (!arguments.length) k = -1 / (6 * coordinates.area());\n    while (++i < n) {\n      a = b;\n      b = coordinates[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [x * k, y * k];\n  };\n\n  // The Sutherland-Hodgman clipping algorithm.\n  // Note: requires the clip polygon to be counterclockwise and convex.\n  coordinates.clip = function(subject) {\n    var input,\n        i = -1,\n        n = coordinates.length,\n        j,\n        m,\n        a = coordinates[n - 1],\n        b,\n        c,\n        d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = coordinates[i];\n      c = input[(m = input.length) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      a = b;\n    }\n    return subject;\n  };\n\n  return coordinates;\n};\n\nfunction d3_geom_polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\nfunction d3_geom_polygonIntersect(c, d, a, b) {\n  var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3,\n      y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3,\n      ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":2192}]],"length":2192}
{"contributors":[],"silentsave":false,"ts":1361191587821,"patch":[[{"diffs":[[0,"var "],[-1,"polygon"],[1,"centroid"],[0," = funct"]],"start1":0,"start2":0,"length1":19,"length2":20},{"diffs":[[0,"oord"],[-1,"inate"],[0,"s)"],[-1," "],[0,"{\n"],[-1,"\n  coordinates.area = function() {\n    var i = 0,\n        n = coordinates.length,\n        area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];\n    while (++i < n"],[1,"function d3_number(x"],[0,") {\n  "],[-1," "],[-1,"   area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];\n    }\n    return area * .5;\n  };\n\n  coordinates.centroid"],[1,"return x != null && !isNaN(x);\n}\nvar mean"],[0," = f"]],"start1":25,"start2":25,"length1":381,"length2":79},{"diffs":[[0,"ion("],[-1,"k"],[1,"array, f"],[0,") {\n"],[-1,"  "],[0,"  var "],[-1,"i = -1,\n        n = coordinates"],[1,"n = array"],[0,".len"]],"start1":108,"start2":108,"length1":52,"length2":35},{"diffs":[[0,"    "],[-1,"  x = 0"],[1,"a"],[0,",\n      "],[-1,"  y"],[1,"m"],[0," = 0"]],"start1":150,"start2":150,"length1":26,"length2":18},{"diffs":[[0,"    "],[-1,"  a,\n        b = coordinates[n - 1]"],[1,"i = -1"],[0,",\n      "],[-1,"  c;\n  "],[1,"j = 0;\n"],[0,"  if ("],[-1,"!"],[0,"argu"]],"start1":172,"start2":172,"length1":65,"length2":35},{"diffs":[[0,"ngth"],[-1,") k = -1 / (6 * coordinates.area());\n    while (++i < n) {\n      a = b;\n      b = coordinates[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [x * k, y * k];\n  };\n\n  // The Sutherland-Hodgman clipping algorithm.\n  // Note: requires the clip polygon to be counterclockwise and convex.\n  coordinates.clip = function(subject) {\n    var input,\n        i = -1,\n        n = coordinates.length,\n        j,\n        m,\n        a = coordinates[n - 1],\n        b,\n        c,\n        d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = coordinates[i];\n      c = input[(m = input.length) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      a = b;\n    }\n    return subject;\n  };\n\n  return coordinates;\n};\n\nfunction d3_geom_polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\nfunction d3_geom_polygonIntersect(c, d, a, b) {\n  var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3,\n      y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3,\n      ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];"],[1," === 1) {\n    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\n  } else {\n    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\n  }\n  return j ? m : undefined;\n};\n\nreturn [mean(coords,function(v){return v[0]}),mean(coords,function(v){return v[1]})]\n"],[0,"\n}"],[-1,"\n"]],"start1":215,"start2":215,"length1":1621,"length2":304}]],"length":519,"saved":false}
{"ts":1361191678822,"patch":[[{"diffs":[[1,"//from d3\n"],[0,"var centroid"]],"start1":0,"start2":0,"length1":12,"length2":22}]],"length":529,"saved":false}
