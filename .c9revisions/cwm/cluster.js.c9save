{"ts":1361368589256,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1361368591483,"patch":[[{"diffs":[[1,"/* MIT license */\r\nvar clusterfck = (function() {var require = function (file, cwd) {\r\n    var resolved = require.resolve(file, cwd || '/');\r\n    var mod = require.modules[resolved];\r\n    if (!mod) throw new Error(\r\n        'Failed to resolve module ' + file + ', tried ' + resolved\r\n    );\r\n    var res = mod._cached ? mod._cached : mod();\r\n    return res;\r\n}\r\n\r\nrequire.paths = [];\r\nrequire.modules = {};\r\nrequire.extensions = [\".js\",\".coffee\"];\r\n\r\nrequire._core = {\r\n    'assert': true,\r\n    'events': true,\r\n    'fs': true,\r\n    'path': true,\r\n    'vm': true\r\n};\r\n\r\nrequire.resolve = (function () {\r\n    return function (x, cwd) {\r\n        if (!cwd) cwd = '/';\r\n        \r\n        if (require._core[x]) return x;\r\n        var path = require.modules.path();\r\n        var y = cwd || '.';\r\n        \r\n        if (x.match(/^(?:\\.\\.?\\/|\\/)/)) {\r\n            var m = loadAsFileSync(path.resolve(y, x))\r\n                || loadAsDirectorySync(path.resolve(y, x));\r\n            if (m) return m;\r\n        }\r\n        \r\n        var n = loadNodeModulesSync(x, y);\r\n        if (n) return n;\r\n        \r\n        throw new Error(\"Cannot find module '\" + x + \"'\");\r\n        \r\n        function loadAsFileSync (x) {\r\n            if (require.modules[x]) {\r\n                return x;\r\n            }\r\n            \r\n            for (var i = 0; i < require.extensions.length; i++) {\r\n                var ext = require.extensions[i];\r\n                if (require.modules[x + ext]) return x + ext;\r\n            }\r\n        }\r\n        \r\n        function loadAsDirectorySync (x) {\r\n            x = x.replace(/\\/+$/, '');\r\n            var pkgfile = x + '/package.json';\r\n            if (require.modules[pkgfile]) {\r\n                var pkg = require.modules[pkgfile]();\r\n                var b = pkg.browserify;\r\n                if (typeof b === 'object' && b.main) {\r\n                    var m = loadAsFileSync(path.resolve(x, b.main));\r\n                    if (m) return m;\r\n                }\r\n                else if (typeof b === 'string') {\r\n                    var m = loadAsFileSync(path.resolve(x, b));\r\n                    if (m) return m;\r\n                }\r\n                else if (pkg.main) {\r\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\r\n                    if (m) return m;\r\n                }\r\n            }\r\n            \r\n            return loadAsFileSync(x + '/index');\r\n        }\r\n        \r\n        function loadNodeModulesSync (x, start) {\r\n            var dirs = nodeModulesPathsSync(start);\r\n            for (var i = 0; i < dirs.length; i++) {\r\n                var dir = dirs[i];\r\n                var m = loadAsFileSync(dir + '/' + x);\r\n                if (m) return m;\r\n                var n = loadAsDirectorySync(dir + '/' + x);\r\n                if (n) return n;\r\n            }\r\n            \r\n            var m = loadAsFileSync(x);\r\n            if (m) return m;\r\n        }\r\n        \r\n        function nodeModulesPathsSync (start) {\r\n            var parts;\r\n            if (start === '/') parts = [ '' ];\r\n            else parts = path.normalize(start).split('/');\r\n            \r\n            var dirs = [];\r\n            for (var i = parts.length - 1; i >= 0; i--) {\r\n                if (parts[i] === 'node_modules') continue;\r\n                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';\r\n                dirs.push(dir);\r\n            }\r\n            \r\n            return dirs;\r\n        }\r\n    };\r\n})();\r\n\r\nrequire.alias = function (from, to) {\r\n    var path = require.modules.path();\r\n    var res = null;\r\n    try {\r\n        res = require.resolve(from + '/package.json', '/');\r\n    }\r\n    catch (err) {\r\n        res = require.resolve(from, '/');\r\n    }\r\n    var basedir = path.dirname(res);\r\n    \r\n    var keys = Object_keys(require.modules);\r\n    \r\n    for (var i = 0; i < keys.length; i++) {\r\n        var key = keys[i];\r\n        if (key.slice(0, basedir.length + 1) === basedir + '/') {\r\n            var f = key.slice(basedir.length);\r\n            require.modules[to + f] = require.modules[basedir + f];\r\n        }\r\n        else if (key === basedir) {\r\n            require.modules[to] = require.modules[basedir];\r\n        }\r\n    }\r\n};\r\n\r\nrequire.define = function (filename, fn) {\r\n    var dirname = require._core[filename]\r\n        ? ''\r\n        : require.modules.path().dirname(filename)\r\n    ;\r\n    \r\n    var require_ = function (file) {\r\n        return require(file, dirname)\r\n    };\r\n    require_.resolve = function (name) {\r\n        return require.resolve(name, dirname);\r\n    };\r\n    require_.modules = require.modules;\r\n    require_.define = require.define;\r\n    var module_ = { exports : {} };\r\n    \r\n    require.modules[filename] = function () {\r\n        require.modules[filename]._cached = module_.exports;\r\n        fn.call(\r\n            module_.exports,\r\n            require_,\r\n            module_,\r\n            module_.exports,\r\n            dirname,\r\n            filename\r\n        );\r\n        require.modules[filename]._cached = module_.exports;\r\n        return module_.exports;\r\n    };\r\n};\r\n\r\nvar Object_keys = Object.keys || function (obj) {\r\n    var res = [];\r\n    for (var key in obj) res.push(key)\r\n    return res;\r\n};\r\n\r\nif (typeof process === 'undefined') process = {};\r\n\r\nif (!process.nextTick) process.nextTick = function (fn) {\r\n    setTimeout(fn, 0);\r\n};\r\n\r\nif (!process.title) process.title = 'browser';\r\n\r\nif (!process.binding) process.binding = function (name) {\r\n    if (name === 'evals') return require('vm')\r\n    else throw new Error('No such module')\r\n};\r\n\r\nif (!process.cwd) process.cwd = function () { return '.' };\r\n\r\nrequire.define(\"path\", function (require, module, exports, __dirname, __filename) {\r\n    function filter (xs, fn) {\r\n    var res = [];\r\n    for (var i = 0; i < xs.length; i++) {\r\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes, empty elements, or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  // if the path tries to go above the root, `up` ends up > 0\r\n  var up = 0;\r\n  for (var i = parts.length; i >= 0; i--) {\r\n    var last = parts[i];\r\n    if (last == '.') {\r\n      parts.splice(i, 1);\r\n    } else if (last === '..') {\r\n      parts.splice(i, 1);\r\n      up++;\r\n    } else if (up) {\r\n      parts.splice(i, 1);\r\n      up--;\r\n    }\r\n  }\r\n\r\n  // if the path is allowed to go above the root, restore leading ..s\r\n  if (allowAboveRoot) {\r\n    for (; up--; up) {\r\n      parts.unshift('..');\r\n    }\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\n// Regex to split a filename into [*, dir, basename, ext]\r\n// posix version\r\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nexports.resolve = function() {\r\nvar resolvedPath = '',\r\n    resolvedAbsolute = false;\r\n\r\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\r\n  var path = (i >= 0)\r\n      ? arguments[i]\r\n      : process.cwd();\r\n\r\n  // Skip empty and invalid entries\r\n  if (typeof path !== 'string' || !path) {\r\n    continue;\r\n  }\r\n\r\n  resolvedPath = path + '/' + resolvedPath;\r\n  resolvedAbsolute = path.charAt(0) === '/';\r\n}\r\n\r\n// At this point the path should be resolved to a full absolute path, but\r\n// handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n// Normalize the path\r\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\r\n    return !!p;\r\n  }), !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nexports.normalize = function(path) {\r\nvar isAbsolute = path.charAt(0) === '/',\r\n    trailingSlash = path.slice(-1) === '/';\r\n\r\n// Normalize the path\r\npath = normalizeArray(filter(path.split('/'), function(p) {\r\n    return !!p;\r\n  }), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n  \r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n\r\n// posix version\r\nexports.join = function() {\r\n  var paths = Array.prototype.slice.call(arguments, 0);\r\n  return exports.normalize(filter(paths, function(p, index) {\r\n    return p && typeof p === 'string';\r\n  }).join('/'));\r\n};\r\n\r\n\r\nexports.dirname = function(path) {\r\n  var dir = splitPathRe.exec(path)[1] || '';\r\n  var isWindows = false;\r\n  if (!dir) {\r\n    // No dirname\r\n    return '.';\r\n  } else if (dir.length === 1 ||\r\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\r\n    // It is just a slash or a drive letter with a slash\r\n    return dir;\r\n  } else {\r\n    // It is a full dirname, strip trailing slash\r\n    return dir.substring(0, dir.length - 1);\r\n  }\r\n};\r\n\r\n\r\nexports.basename = function(path, ext) {\r\n  var f = splitPathRe.exec(path)[2] || '';\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nexports.extname = function(path) {\r\n  return splitPathRe.exec(path)[3] || '';\r\n};\r\n\r\n});\r\n\r\nrequire.define(\"/clusterfck.js\", function (require, module, exports, __dirname, __filename) {\r\n    module.exports = {\r\n   hcluster: require(\"./hcluster\"),\r\n   kmeans: require(\"./kmeans\")\r\n};\r\n});\r\n\r\nrequire.define(\"/hcluster.js\", function (require, module, exports, __dirname, __filename) {\r\n    var distances = require(\"./distance\");\r\n\r\nvar HierarchicalClustering = function(distance, linkage, threshold) {\r\n   this.distance = distance;\r\n   this.linkage = linkage;\r\n   this.threshold = threshold == undefined ? Infinity : threshold;\r\n}\r\n\r\nHierarchicalClustering.prototype = {\r\n   cluster : function(items, snapshotPeriod, snapshotCb) {\r\n      this.clusters = [];\r\n      this.dists = [];  // distances between each pair of clusters\r\n      this.mins = []; // closest cluster for each cluster\r\n      this.index = []; // keep a hash of all clusters by key\r\n      \r\n      for (var i = 0; i < items.length; i++) {\r\n         var cluster = {\r\n            value: items[i],\r\n            key: i,\r\n            index: i,\r\n            size: 1\r\n         };\r\n         this.clusters[i] = cluster;\r\n         this.index[i] = cluster;\r\n         this.dists[i] = [];\r\n         this.mins[i] = 0;\r\n      }\r\n\r\n      for (var i = 0; i < this.clusters.length; i++) {\r\n         for (var j = 0; j <= i; j++) {\r\n            var dist = (i == j) ? Infinity : \r\n               this.distance(this.clusters[i].value, this.clusters[j].value);\r\n            this.dists[i][j] = dist;\r\n            this.dists[j][i] = dist;\r\n\r\n            if (dist < this.dists[i][this.mins[i]]) {\r\n               this.mins[i] = j;               \r\n            }\r\n         }\r\n      }\r\n\r\n      var merged = this.mergeClosest();\r\n      var i = 0;\r\n      while (merged) {\r\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\r\n           snapshotCb(this.clusters);           \r\n        }\r\n        merged = this.mergeClosest();\r\n      }\r\n    \r\n      this.clusters.forEach(function(cluster) {\r\n        // clean up metadata used for clustering\r\n        delete cluster.key;\r\n        delete cluster.index;\r\n      });\r\n\r\n      return this.clusters;\r\n   },\r\n  \r\n   mergeClosest: function() {\r\n      // find two closest clusters from cached mins\r\n      var minKey = 0, min = Infinity;\r\n      for (var i = 0; i < this.clusters.length; i++) {\r\n         var key = this.clusters[i].key,\r\n             dist = this.dists[key][this.mins[key]];\r\n         if (dist < min) {\r\n            minKey = key;\r\n            min = dist;\r\n         }\r\n      }\r\n      if (min >= this.threshold) {\r\n         return false;         \r\n      }\r\n\r\n      var c1 = this.index[minKey],\r\n          c2 = this.index[this.mins[minKey]];\r\n\r\n      // merge two closest clusters\r\n      var merged = {\r\n         left: c1,\r\n         right: c2,\r\n         key: c1.key,\r\n         size: c1.size + c2.size\r\n      };\r\n\r\n      this.clusters[c1.index] = merged;\r\n      this.clusters.splice(c2.index, 1);\r\n      this.index[c1.key] = merged;\r\n\r\n      // update distances with new merged cluster\r\n      for (var i = 0; i < this.clusters.length; i++) {\r\n         var ci = this.clusters[i];\r\n         var dist;\r\n         if (c1.key == ci.key) {\r\n            dist = Infinity;            \r\n         }\r\n         else if (this.linkage == \"single\") {\r\n            dist = this.dists[c1.key][ci.key];\r\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\r\n               dist = this.dists[c2.key][ci.key];\r\n            }\r\n         }\r\n         else if (this.linkage == \"complete\") {\r\n            dist = this.dists[c1.key][ci.key];\r\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\r\n               dist = this.dists[c2.key][ci.key];              \r\n            }\r\n         }\r\n         else if (this.linkage == \"average\") {\r\n            dist = (this.dists[c1.key][ci.key] * c1.size\r\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\r\n         }\r\n         else {\r\n            dist = this.distance(ci.value, c1.value);            \r\n         }\r\n\r\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\r\n      }\r\n\r\n    \r\n      // update cached mins\r\n      for (var i = 0; i < this.clusters.length; i++) {\r\n         var key1 = this.clusters[i].key;        \r\n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\r\n            var min = key1;\r\n            for (var j = 0; j < this.clusters.length; j++) {\r\n               var key2 = this.clusters[j].key;\r\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\r\n                  min = key2;                  \r\n               }\r\n            }\r\n            this.mins[key1] = min;\r\n         }\r\n         this.clusters[i].index = i;\r\n      }\r\n    \r\n      // clean up metadata used for clustering\r\n      delete c1.key; delete c2.key;\r\n      delete c1.index; delete c2.index;\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\r\n   distance = distance || \"euclidean\";\r\n   linkage = linkage || \"average\";\r\n\r\n   if (typeof distance == \"string\") {\r\n     distance = distances[distance];\r\n   }\r\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\r\n                  .cluster(items, snapshot, snapshotCallback);\r\n      \r\n   if (threshold === undefined) {\r\n      return clusters[0]; // all clustered into one\r\n   }\r\n   return clusters;\r\n}\r\n\r\nmodule.exports = hcluster;\r\n\r\n});\r\n\r\nrequire.define(\"/distance.js\", function (require, module, exports, __dirname, __filename) {\r\n    module.exports = {\r\n  euclidean: function(v1, v2) {\r\n      var total = 0;\r\n      for (var i = 0; i < v1.length; i++) {\r\n         total += Math.pow(v2[i] - v1[i], 2);      \r\n      }\r\n      return Math.sqrt(total);\r\n   },\r\n   manhattan: function(v1, v2) {\r\n     var total = 0;\r\n     for (var i = 0; i < v1.length ; i++) {\r\n        total += Math.abs(v2[i] - v1[i]);      \r\n     }\r\n     return total;\r\n   },\r\n   max: function(v1, v2) {\r\n     var max = 0;\r\n     for (var i = 0; i < v1.length; i++) {\r\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \r\n     }\r\n     return max;\r\n   }\r\n};\r\n});\r\n\r\nrequire.define(\"/kmeans.js\", function (require, module, exports, __dirname, __filename) {\r\n    var distances = require(\"./distance\");\r\n\r\nfunction randomCentroids(points, k) {\r\n   var centroids = points.slice(0); // copy\r\n   centroids.sort(function() {\r\n      return (Math.round(Math.random()) - 0.5);\r\n   });\r\n   return centroids.slice(0, k);\r\n}\r\n\r\nfunction closestCentroid(point, centroids, distance) {\r\n   var min = Infinity,\r\n       index = 0;\r\n   for (var i = 0; i < centroids.length; i++) {\r\n      var dist = distance(point, centroids[i]);\r\n      if (dist < min) {\r\n         min = dist;\r\n         index = i;\r\n      }\r\n   }\r\n   return index;\r\n}\r\n\r\nfunction kmeans(points, k, distance, snapshotPeriod, snapshotCb) {\r\n   distance = distance || \"euclidean\";\r\n   if (typeof distance == \"string\") {\r\n      distance = distances[distance];\r\n   }\r\n   \r\n   var centroids = randomCentroids(points, k);\r\n   var assignment = new Array(points.length);\r\n   var clusters = new Array(k);\r\n\r\n   var iterations = 0;   \r\n   var movement = true;\r\n   while (movement) {\r\n      // update point-to-centroid assignments\r\n      for (var i = 0; i < points.length; i++) {\r\n         assignment[i] = closestCentroid(points[i], centroids, distance);\r\n      }\r\n\r\n      // update location of each centroid\r\n      movement = false;\r\n      for (var j = 0; j < k; j++) {\r\n         var assigned = [];\r\n         assignment.forEach(function(centroid, index) {\r\n            if (centroid == j) {\r\n               assigned.push(points[index]);\r\n            }\r\n         });\r\n\r\n         if (!assigned.length) {\r\n            continue;\r\n         }\r\n         var centroid = centroids[j];\r\n         var newCentroid = new Array(centroid.length);\r\n\r\n         for (var g = 0; g < centroid.length; g++) {\r\n            var sum = 0;\r\n            for (var i = 0; i < assigned.length; i++) {\r\n               sum += assigned[i][g];\r\n            }\r\n            newCentroid[g] = sum / assigned.length;\r\n            \r\n            if (newCentroid[g] != centroid[g]) {\r\n               movement = true;\r\n            }\r\n         }\r\n         centroids[j] = newCentroid;\r\n         clusters[j] = assigned;\r\n      }\r\n      \r\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\r\n         snapshotCb(clusters);\r\n      }\r\n   }\r\n   return clusters;\r\n}\r\n\r\nmodule.exports = kmeans;\r\n\r\n});\r\n return require('/clusterfck')})();"]],"start1":0,"start2":0,"length1":0,"length2":17666}]],"length":17666,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361371860788,"patch":[[{"diffs":[[0," lic"],[-1,"ense */"],[1,"https://github.com/harthur/clusterfckense */\r\n//from https://github.com/harthur/clusterfck"],[0,"\r\nva"]],"start1":6,"start2":6,"length1":15,"length2":98}]],"length":17749,"saved":false}
