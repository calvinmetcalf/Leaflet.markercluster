{"ts":1361043673128,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1361043675215,"patch":[[{"diffs":[[1,"/****************************************************************************** \n    rtree.js - General-Purpose Non-Recursive Javascript R-Tree Library\n    Version 0.6.2, December 5st 2009\n\n  Copyright (c) 2009 Jon-Carlos Rivera\n  \n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n  \n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tJon-Carlos Rivera - imbcmdth@hotmail.com\n******************************************************************************/\n\n/**\n * RTree - A simple r-tree structure for great results.\n * @constructor\n */\nvar RTree = function(width){\n\t// Variables to control tree-dimensions\n\tvar _Min_Width = 3;  // Minimum width of any node before a merge\n\tvar _Max_Width = 6;  // Maximum width of any node before a split\n\tif(!isNaN(width)){ _Min_Width = Math.floor(width/2.0); _Max_Width = width;}\n\t// Start with an empty root-tree\n\tvar _T = {x:0, y:0, w:0, h:0, id:\"root\", nodes:[] };\n    \n\tvar isArray = function(o) {\n\t\treturn Object.prototype.toString.call(o) === '[object Array]'; \n\t};\n\n\t/* @function\n\t * @description Function to generate unique strings for element IDs\n\t * @param {String} n\t\t\tThe prefix to use for the IDs generated.\n\t * @return {String}\t\t\t\tA guarenteed unique ID.\n\t */\n    var _name_to_id = (function() {\n        // hide our idCache inside this closure\n        var idCache = {};\n\n        // return the api: our function that returns a unique string with incrementing number appended to given idPrefix\n        return function(idPrefix) {\n            var idVal = 0;\n            if(idPrefix in idCache) {\n                idVal = idCache[idPrefix]++;\n            } else {\n                idCache[idPrefix] = 0;\n            }\n            return idPrefix + \"_\" + idVal;\n        }\n    })();\n\n\t// This is my special addition to the world of r-trees\n\t// every other (simple) method I found produced crap trees\n\t// this skews insertions to prefering squarer and emptier nodes\n\tRTree.Rectangle.squarified_ratio = function(l, w, fill) {\n\t  // Area of new enlarged rectangle\n\t  var lperi = (l + w) / 2.0; // Average size of a side of the new rectangle\n\t  var larea = l * w; // Area of new rectangle\n\t  // return the ratio of the perimeter to the area - the closer to 1 we are, \n\t  // the more \"square\" a rectangle is. conversly, when approaching zero the \n\t  // more elongated a rectangle is\n\t  var lgeo = larea / (lperi*lperi);\n\t  return(larea * fill / lgeo); \n\t};\n\t\n\t/* find the best specific node(s) for object to be deleted from\n\t * [ leaf node parent ] = _remove_subtree(rectangle, object, root)\n\t * @private\n\t */\n\tvar _remove_subtree = function(rect, obj, root) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\tvar count_stack = []; // Contains the elements that overlap\n\t\tvar ret_array = [];\n\t\tvar current_depth = 1;\n\t\t\n\t\tif(!rect || !RTree.Rectangle.overlap_rectangle(rect, root))\n\t\t return ret_array;\n\n\t\tvar ret_obj = {x:rect.x, y:rect.y, w:rect.w, h:rect.h, target:obj};\n\t\t\n\t\tcount_stack.push(root.nodes.length);\n\t\thit_stack.push(root);\n\n\t\tdo {\n\t\t\tvar tree = hit_stack.pop();\n\t\t\tvar i = count_stack.pop()-1;\n\t\t\t\n\t\t  if(\"target\" in ret_obj) { // We are searching for a target\n\t\t\t\twhile(i >= 0)\t{\n\t\t\t\t\tvar ltree = tree.nodes[i];\n\t\t\t\t\tif(RTree.Rectangle.overlap_rectangle(ret_obj, ltree)) {\n\t\t\t\t\t\tif( (ret_obj.target && \"leaf\" in ltree && ltree.leaf === ret_obj.target)\n\t\t\t\t\t\t\t||(!ret_obj.target && (\"leaf\" in ltree || RTree.Rectangle.contains_rectangle(ltree, ret_obj)))) { // A Match !!\n\t\t\t\t  \t\t// Yup we found a match...\n\t\t\t\t  \t\t// we can cancel search and start walking up the list\n\t\t\t\t  \t\tif(\"nodes\" in ltree) {// If we are deleting a node not a leaf...\n\t\t\t\t  \t\t\tret_array = _search_subtree(ltree, true, [], ltree);\n\t\t\t\t  \t\t\ttree.nodes.splice(i, 1); \n\t\t\t\t  \t\t} else {\n\t\t\t\t\t\t\t\tret_array = tree.nodes.splice(i, 1); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Resize MBR down...\n\t\t\t\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t\t\t\t\tdelete ret_obj.target;\n\t\t\t\t\t\t\tif(tree.nodes.length < _Min_Width) { // Underflow\n\t\t\t\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, [], tree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t  \t\t}/*\telse if(\"load\" in ltree) { // A load\n\t\t\t\t  \t}*/\telse if(\"nodes\" in ltree) { // Not a Leaf\n\t\t\t\t  \t\tcurrent_depth += 1;\n\t\t\t\t  \t\tcount_stack.push(i);\n\t\t\t\t  \t\thit_stack.push(tree);\n\t\t\t\t  \t\ttree = ltree;\n\t\t\t\t  \t\ti = ltree.nodes.length;\n\t\t\t\t  \t}\n\t\t\t\t  }\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t} else if(\"nodes\" in ret_obj) { // We are unsplitting\n\t\t\t\ttree.nodes.splice(i+1, 1); // Remove unsplit node\n\t\t\t\t// ret_obj.nodes contains a list of elements removed from the tree so far\n\t\t\t\tif(tree.nodes.length > 0)\n\t\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t\tfor(var t = 0;t<ret_obj.nodes.length;t++)\n\t\t\t\t\t_insert_subtree(ret_obj.nodes[t], tree);\n\t\t\t\tret_obj.nodes.length = 0;\n\t\t\t\tif(hit_stack.length == 0 && tree.nodes.length <= 1) { // Underflow..on root!\n\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);\n\t\t\t\t\ttree.nodes.length = 0;\n\t\t\t\t\thit_stack.push(tree);\n\t\t\t\t\tcount_stack.push(1);\n\t\t\t\t} else if(hit_stack.length > 0 && tree.nodes.length < _Min_Width) { // Underflow..AGAIN!\n\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);\n\t\t\t\t\ttree.nodes.length = 0;\t\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tdelete ret_obj.nodes; // Just start resizing\n\t\t\t\t}\n\t\t\t} else { // we are just resizing\n\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t}\n\t\t\tcurrent_depth -= 1;\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn(ret_array);\n\t};\n\n\t/* choose the best damn node for rectangle to be inserted into\n\t * [ leaf node parent ] = _choose_leaf_subtree(rectangle, root to start search at)\n\t * @private\n\t */\n\tvar _choose_leaf_subtree = function(rect, root) {\n\t\tvar best_choice_index = -1;\n\t\tvar best_choice_stack = [];\n\t\tvar best_choice_area;\n\t\t\n\t\tvar load_callback = function(local_tree, local_node){\n\t\t\treturn(function(data) { \n\t\t\t\tlocal_tree._attach_data(local_node, data);\n\t\t\t});\n\t\t};\n\t\n\t\tbest_choice_stack.push(root);\n\t\tvar nodes = root.nodes;\t\n\n\t\tdo {\t\n\t\t\tif(best_choice_index != -1)\t{\n\t\t\t\tbest_choice_stack.push(nodes[best_choice_index]);\n\t\t\t\tnodes = nodes[best_choice_index].nodes;\n\t\t\t\tbest_choice_index = -1;\n\t\t\t}\n\t\n\t\t\tfor(var i = nodes.length-1; i >= 0; i--) {\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t\tif(\"leaf\" in ltree) {  \n\t\t\t\t\t// Bail out of everything and start inserting\n\t\t\t\t\tbest_choice_index = -1;\n\t\t\t\t\tbreak;\n\t\t\t  } /*else if(ltree.load) {\n  \t\t\t\tthrow( \"Can't insert into partially loaded tree ... yet!\");\n  \t\t\t\t//jQuery.getJSON(ltree.load, load_callback(this, ltree));\n  \t\t\t\t//delete ltree.load;\n  \t\t\t}*/\n\t\t\t  // Area of new enlarged rectangle\n\t\t\t  var old_lratio = RTree.Rectangle.squarified_ratio(ltree.w, ltree.h, ltree.nodes.length+1);\n\n\t\t\t  // Enlarge rectangle to fit new rectangle\n\t\t\t  var nw = Math.max(ltree.x+ltree.w, rect.x+rect.w) - Math.min(ltree.x, rect.x);\n\t\t\t  var nh = Math.max(ltree.y+ltree.h, rect.y+rect.h) - Math.min(ltree.y, rect.y);\n\t\t\t  \n\t\t\t  // Area of new enlarged rectangle\n\t\t\t  var lratio = RTree.Rectangle.squarified_ratio(nw, nh, ltree.nodes.length+2);\n\t\t\t  \n\t\t\t  if(best_choice_index < 0 || Math.abs(lratio - old_lratio) < best_choice_area) {\n\t\t\t  \tbest_choice_area = Math.abs(lratio - old_lratio); best_choice_index = i;\n\t\t\t  }\n\t\t\t}\n\t\t}while(best_choice_index != -1);\n\n\t\treturn(best_choice_stack);\n\t};\n\n\t/* split a set of nodes into two roughly equally-filled nodes\n\t * [ an array of two new arrays of nodes ] = linear_split(array of nodes)\n\t * @private\n\t */\n\tvar _linear_split = function(nodes) {\n\t\tvar n = _pick_linear(nodes);\n\t\twhile(nodes.length > 0)\t{\n\t\t\t_pick_next(nodes, n[0], n[1]);\n\t\t}\n\t\treturn(n);\n\t};\n\t\n\t/* insert the best source rectangle into the best fitting parent node: a or b\n\t * [] = pick_next(array of source nodes, target node array a, target node array b)\n\t * @private\n\t */\n\tvar _pick_next = function(nodes, a, b) {\n\t  // Area of new enlarged rectangle\n\t\tvar area_a = RTree.Rectangle.squarified_ratio(a.w, a.h, a.nodes.length+1);\n\t\tvar area_b = RTree.Rectangle.squarified_ratio(b.w, b.h, b.nodes.length+1);\n\t\tvar high_area_delta;\n\t\tvar high_area_node;\n\t\tvar lowest_growth_group;\n\t\t\n\t\tfor(var i = nodes.length-1; i>=0;i--) {\n\t\t\tvar l = nodes[i];\n\t\t\tvar new_area_a = {};\n\t\t\tnew_area_a.x = Math.min(a.x, l.x); new_area_a.y = Math.min(a.y, l.y);\n\t\t\tnew_area_a.w = Math.max(a.x+a.w, l.x+l.w) - new_area_a.x;\tnew_area_a.h = Math.max(a.y+a.h, l.y+l.h) - new_area_a.y;\n\t\t\tvar change_new_area_a = Math.abs(RTree.Rectangle.squarified_ratio(new_area_a.w, new_area_a.h, a.nodes.length+2) - area_a);\n\t\n\t\t\tvar new_area_b = {};\n\t\t\tnew_area_b.x = Math.min(b.x, l.x); new_area_b.y = Math.min(b.y, l.y);\n\t\t\tnew_area_b.w = Math.max(b.x+b.w, l.x+l.w) - new_area_b.x;\tnew_area_b.h = Math.max(b.y+b.h, l.y+l.h) - new_area_b.y;\n\t\t\tvar change_new_area_b = Math.abs(RTree.Rectangle.squarified_ratio(new_area_b.w, new_area_b.h, b.nodes.length+2) - area_b);\n\n\t\t\tif( !high_area_node || !high_area_delta || Math.abs( change_new_area_b - change_new_area_a ) < high_area_delta ) {\n\t\t\t\thigh_area_node = i;\n\t\t\t\thigh_area_delta = Math.abs(change_new_area_b-change_new_area_a);\n\t\t\t\tlowest_growth_group = change_new_area_b < change_new_area_a ? b : a;\n\t\t\t}\n\t\t}\n\t\tvar temp_node = nodes.splice(high_area_node, 1)[0];\n\t\tif(a.nodes.length + nodes.length + 1 <= _Min_Width)\t{\n\t\t\ta.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(a, temp_node);\n\t\t}\telse if(b.nodes.length + nodes.length + 1 <= _Min_Width) {\n\t\t\tb.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(b, temp_node);\n\t\t}\n\t\telse {\n\t\t\tlowest_growth_group.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(lowest_growth_group, temp_node);\n\t\t}\n\t};\n\n\t/* pick the \"best\" two starter nodes to use as seeds using the \"linear\" criteria\n\t * [ an array of two new arrays of nodes ] = pick_linear(array of source nodes)\n\t * @private\n\t */\n\tvar _pick_linear = function(nodes) {\n\t\tvar lowest_high_x = nodes.length-1;\n\t\tvar highest_low_x = 0;\n\t\tvar lowest_high_y = nodes.length-1;\n\t\tvar highest_low_y = 0;\n        var t1, t2;\n\t\t\n\t\tfor(var i = nodes.length-2; i>=0;i--)\t{\n\t\t\tvar l = nodes[i];\n\t\t\tif(l.x > nodes[highest_low_x].x ) highest_low_x = i;\n\t\t\telse if(l.x+l.w < nodes[lowest_high_x].x+nodes[lowest_high_x].w) lowest_high_x = i;\n\t\t\tif(l.y > nodes[highest_low_y].y ) highest_low_y = i;\n\t\t\telse if(l.y+l.h < nodes[lowest_high_y].y+nodes[lowest_high_y].h) lowest_high_y = i;\n\t\t}\n\t\tvar dx = Math.abs((nodes[lowest_high_x].x+nodes[lowest_high_x].w) - nodes[highest_low_x].x);\n\t\tvar dy = Math.abs((nodes[lowest_high_y].y+nodes[lowest_high_y].h) - nodes[highest_low_y].y);\n\t\tif( dx > dy )\t{ \n\t\t\tif(lowest_high_x > highest_low_x)\t{\n\t\t\t\tt1 = nodes.splice(lowest_high_x, 1)[0];\n\t\t\t\tt2 = nodes.splice(highest_low_x, 1)[0];\n\t\t\t}\telse {\n\t\t\t\tt2 = nodes.splice(highest_low_x, 1)[0];\n\t\t\t\tt1 = nodes.splice(lowest_high_x, 1)[0];\n\t\t\t}\n\t\t}\telse {\n\t\t\tif(lowest_high_y > highest_low_y)\t{\n\t\t\t\tt1 = nodes.splice(lowest_high_y, 1)[0];\n\t\t\t\tt2 = nodes.splice(highest_low_y, 1)[0];\n\t\t\t}\telse {\n\t\t\t\tt2 = nodes.splice(highest_low_y, 1)[0];\n\t\t\t\tt1 = nodes.splice(lowest_high_y, 1)[0];\n\t\t\t}\n\t\t}\n\t\treturn([{x:t1.x, y:t1.y, w:t1.w, h:t1.h, nodes:[t1]},\n\t\t\t      {x:t2.x, y:t2.y, w:t2.w, h:t2.h, nodes:[t2]} ]);\n\t};\n\t\n\tvar _attach_data = function(node, more_tree){\n\t\tnode.nodes = more_tree.nodes;\n\t\tnode.x = more_tree.x; node.y = more_tree.y;\n\t\tnode.w = more_tree.w; node.h = more_tree.h;\n\t\treturn(node);\n\t};\n\n\t/* non-recursive internal search function \n\t * [ nodes | objects ] = _search_subtree(rectangle, [return node data], [array to fill], root to begin search at)\n\t * @private\n\t */\n\tvar _search_subtree = function(rect, return_node, return_array, root) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\n\t\tif(!RTree.Rectangle.overlap_rectangle(rect, root))\n\t\t return(return_array);\n\t\n\t\tvar load_callback = function(local_tree, local_node){\n\t\t\treturn(function(data) { \n\t\t\t\tlocal_tree._attach_data(local_node, data);\n\t\t\t});\n\t\t};\n\t\n\t\thit_stack.push(root.nodes);\n\t\n\t\tdo {\n\t\t\tvar nodes = hit_stack.pop();\n\t\n\t\t\tfor(var i = nodes.length-1; i >= 0; i--) {\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t  if(RTree.Rectangle.overlap_rectangle(rect, ltree)) {\n\t\t\t  \tif(\"nodes\" in ltree) { // Not a Leaf\n\t\t\t  \t\thit_stack.push(ltree.nodes);\n\t\t\t  \t} else if(\"leaf\" in ltree) { // A Leaf !!\n\t\t\t  \t\tif(!return_node)\n\t\t  \t\t\t\treturn_array.push(ltree.leaf);\n\t\t  \t\t\telse\n\t\t  \t\t\t\treturn_array.push(ltree);\n\t\t  \t\t}/*\telse if(\"load\" in ltree) { // We need to fetch a URL for some more tree data\n\t  \t\t\t\tjQuery.getJSON(ltree.load, load_callback(this, ltree));\n\t  \t\t\t\tdelete ltree.load;\n\t  \t\t\t//\ti++; // Replay this entry\n\t  \t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn(return_array);\n\t};\n\t\n\t/* non-recursive internal insert function\n\t * [] = _insert_subtree(rectangle, object to insert, root to begin insertion at)\n\t * @private\n\t */\n\tvar _insert_subtree = function(node, root) {\n\t\tvar bc; // Best Current node\n\t\t// Initial insertion is special because we resize the Tree and we don't\n\t\t// care about any overflow (seriously, how can the first object overflow?)\n\t\tif(root.nodes.length == 0) {\n\t\t\troot.x = node.x; root.y = node.y;\n\t\t\troot.w = node.w; root.h = node.h;\n\t\t\troot.nodes.push(node);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Find the best fitting leaf node\n\t\t// choose_leaf returns an array of all tree levels (including root)\n\t\t// that were traversed while trying to find the leaf\n\t\tvar tree_stack = _choose_leaf_subtree(node, root);\n\t\tvar ret_obj = node;//{x:rect.x,y:rect.y,w:rect.w,h:rect.h, leaf:obj};\n\t\n\t\t// Walk back up the tree resizing and inserting as needed\n\t\tdo {\n\t\t\t//handle the case of an empty node (from a split)\n\t\t\tif(bc && \"nodes\" in bc && bc.nodes.length == 0) {\n\t\t\t\tvar pbc = bc; // Past bc\n\t\t\t\tbc = tree_stack.pop();\n\t\t\t\tfor(var t=0;t<bc.nodes.length;t++)\n\t\t\t\t\tif(bc.nodes[t] === pbc || bc.nodes[t].nodes.length == 0) {\n\t\t\t\t\t\tbc.nodes.splice(t, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbc = tree_stack.pop();\n\t\t\t}\n\t\t\t\n\t\t\t// If there is data attached to this ret_obj\n\t\t\tif(\"leaf\" in ret_obj || \"nodes\" in ret_obj || isArray(ret_obj)) { \n\t\t\t\t// Do Insert\n\t\t\t\tif(isArray(ret_obj)) {\n\t\t\t\t\tfor(var ai = 0; ai < ret_obj.length; ai++) {\n\t\t\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj[ai]);\n\t\t\t\t\t}\n\t\t\t\t\tbc.nodes = bc.nodes.concat(ret_obj); \n\t\t\t\t} else {\n\t\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj);\n\t\t\t\t\tbc.nodes.push(ret_obj); // Do Insert\n\t\t\t\t}\n\t\n\t\t\t\tif(bc.nodes.length <= _Max_Width)\t{ // Start Resizeing Up the Tree\n\t\t\t\t\tret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};\n\t\t\t\t}\telse { // Otherwise Split this Node\n\t\t\t\t\t// linear_split() returns an array containing two new nodes\n\t\t\t\t\t// formed from the split of the previous node's overflow\n\t\t\t\t\tvar a = _linear_split(bc.nodes);\n\t\t\t\t\tret_obj = a;//[1];\n\t\t\t\t\t\n\t\t\t\t\tif(tree_stack.length < 1)\t{ // If are splitting the root..\n\t\t\t\t\t\tbc.nodes.push(a[0]);\n\t\t\t\t\t\ttree_stack.push(bc);     // Reconsider the root element\n\t\t\t\t\t\tret_obj = a[1];\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\tdelete bc;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\telse { // Otherwise Do Resize\n\t\t\t\t//Just keep applying the new bounding rectangle to the parents..\n\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj);\n\t\t\t\tret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};\n\t\t\t}\n\t\t} while(tree_stack.length > 0);\n\t};\n\n\t/* quick 'n' dirty function for plugins or manually drawing the tree\n\t * [ tree ] = RTree.get_tree(): returns the raw tree data. useful for adding\n\t * @public\n\t * !! DEPRECATED !!\n\t */\n\tthis.get_tree = function() {\n\t\treturn _T;\n\t};\n\t\n\t/* quick 'n' dirty function for plugins or manually loading the tree\n\t * [ tree ] = RTree.set_tree(sub-tree, where to attach): returns the raw tree data. useful for adding\n\t * @public\n\t * !! DEPRECATED !!\n\t */\n\tthis.set_tree = function(new_tree, where) {\n\t\tif(!where)\n\t\t\twhere = _T;\n\t\treturn(_attach_data(where, new_tree));\n\t};\n\t\n\t/* non-recursive search function \n\t * [ nodes | objects ] = RTree.search(rectangle, [return node data], [array to fill])\n\t * @public\n\t */\n\tthis.search = function(rect, return_node, return_array) {\n\t\tif(arguments.length < 1)\n\t\t\tthrow \"Wrong number of arguments. RT.Search requires at least a bounding rectangle.\"\n\n\t\tswitch(arguments.length) {\n\t\t\tcase 1:\n\t\t\t\targuments[1] = false;// Add an \"return node\" flag - may be removed in future\n\t\t\tcase 2:\n\t\t\t\targuments[2] = []; // Add an empty array to contain results\n\t\t\tcase 3:\n\t\t\t\targuments[3] = _T; // Add root node to end of argument list\n\t\t\tdefault:\n\t\t\t\targuments.length = 4;\n\t\t}\n\t\treturn(_search_subtree.apply(this, arguments));\n\t};\n\t\t\n\t/* partially-recursive toJSON function\n\t * [ string ] = RTree.toJSON([rectangle], [tree])\n\t * @public\n\t */\n\tthis.toJSON = function(rect, tree) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\tvar count_stack = []; // Contains the elements that overlap\n\t\tvar return_stack = {}; // Contains the elements that overlap\n\t\tvar max_depth = 3;  // This triggers recursion and tree-splitting\n\t\tvar current_depth = 1;\n\t\tvar return_string = \"\";\n\t\t\n\t\tif(rect && !RTree.Rectangle.overlap_rectangle(rect, _T))\n\t\t return \"\";\n\t\t\n\t\tif(!tree)\t{\n\t\t\tcount_stack.push(_T.nodes.length);\n\t\t\thit_stack.push(_T.nodes);\n\t\t\treturn_string += \"var main_tree = {x:\"+_T.x.toFixed()+\",y:\"+_T.y.toFixed()+\",w:\"+_T.w.toFixed()+\",h:\"+_T.h.toFixed()+\",nodes:[\";\n\t\t}\telse {\n\t\t\tmax_depth += 4;\n\t\t\tcount_stack.push(tree.nodes.length);\n\t\t\thit_stack.push(tree.nodes);\n\t\t\treturn_string += \"var main_tree = {x:\"+tree.x.toFixed()+\",y:\"+tree.y.toFixed()+\",w:\"+tree.w.toFixed()+\",h:\"+tree.h.toFixed()+\",nodes:[\";\n\t\t}\n\t\n\t\tdo {\n\t\t\tvar nodes = hit_stack.pop();\n\t\t\tvar i = count_stack.pop()-1;\n\t\t\t\n\t\t\tif(i >= 0 && i < nodes.length-1)\n\t\t\t\treturn_string += \",\";\n\t\t\t\t\n\t\t\twhile(i >= 0)\t{\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t  if(!rect || RTree.Rectangle.overlap_rectangle(rect, ltree)) {\n\t\t\t  \tif(ltree.nodes) { // Not a Leaf\n\t\t\t  \t\tif(current_depth >= max_depth) {\n\t\t\t  \t\t\tvar len = return_stack.length;\n\t\t\t  \t\t\tvar nam = _name_to_id(\"saved_subtree\");\n\t\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",load:'\"+nam+\".js'}\";\n\t\t\t  \t\t\treturn_stack[nam] = this.toJSON(rect, ltree);\n\t\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\t\treturn_string += \",\"\n\t\t\t  \t\t}\telse {\n\t\t\t\t  \t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",nodes:[\";\n\t\t\t\t  \t\tcurrent_depth += 1;\n\t\t\t\t  \t\tcount_stack.push(i);\n\t\t\t\t  \t\thit_stack.push(nodes);\n\t\t\t\t  \t\tnodes = ltree.nodes;\n\t\t\t\t  \t\ti = ltree.nodes.length;\n\t\t\t\t  \t}\n\t\t\t  \t}\telse if(ltree.leaf) { // A Leaf !!\n\t\t\t  \t\tvar data = ltree.leaf.toJSON ? ltree.leaf.toJSON() : JSON.stringify(ltree.leaf);\n\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",leaf:\" + data + \"}\";\n\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\treturn_string += \",\"\n\t\t  \t\t}\telse if(ltree.load) { // A load\n\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",load:'\" + ltree.load + \"'}\";\n\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\treturn_string += \",\"\n\t\t\t  \t}\n\t\t\t\t}\n\t\t\t\ti -= 1;\n\t\t\t}\n\t\t\tif(i < 0)\t{\n\t\t\t\t\treturn_string += \"]}\"; current_depth -= 1;\n\t\t\t}\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn_string+=\";\";\n\t\t\n\t\tfor(var my_key in return_stack) {\n\t\t\treturn_string += \"\\nvar \" + my_key + \" = function(){\" + return_stack[my_key] + \" return(main_tree);};\";\n\t\t}\n\t\treturn(return_string);\n\t};\n\t\n\t/* non-recursive function that deletes a specific\n\t * [ number ] = RTree.remove(rectangle, obj)\n\t */\n\tthis.remove = function(rect, obj) {\n\t\tif(arguments.length < 1)\n\t\t\tthrow \"Wrong number of arguments. RT.remove requires at least a bounding rectangle.\"\n\n\t\tswitch(arguments.length) {\n\t\t\tcase 1:\n\t\t\t\targuments[1] = false; // obj == false for conditionals\n\t\t\tcase 2:\n\t\t\t\targuments[2] = _T; // Add root node to end of argument list\n\t\t\tdefault:\n\t\t\t\targuments.length = 3;\n\t\t}\n\t\tif(arguments[1] === false) { // Do area-wide delete\n\t\t\tvar numberdeleted = 0;\n\t\t\tvar ret_array = [];\n\t\t\tdo { \n\t\t\t\tnumberdeleted=ret_array.length; \n\t\t\t\tret_array = ret_array.concat(_remove_subtree.apply(this, arguments));\n\t\t\t}while( numberdeleted !=  ret_array.length);\n\t\t\treturn ret_array;\n\t\t}\n\t\telse { // Delete a specific item\n\t\t\treturn(_remove_subtree.apply(this, arguments));\n\t\t}\n\t};\n\t\t\n\t/* non-recursive insert function\n\t * [] = RTree.insert(rectangle, object to insert)\n\t */\n\tthis.insert = function(rect, obj) {\n\t\tif(arguments.length < 2)\n\t\t\tthrow \"Wrong number of arguments. RT.Insert requires at least a bounding rectangle and an object.\"\n\t\t\n\t\treturn(_insert_subtree({x:rect.x,y:rect.y,w:rect.w,h:rect.h,leaf:obj}, _T));\n\t};\n\t\n\t/* non-recursive delete function\n\t * [deleted object] = RTree.remove(rectangle, [object to delete])\n\t */\n\n//End of RTree\n};\n\n/* Rectangle - Generic rectangle object - Not yet used */\n\nRTree.Rectangle = function(ix, iy, iw, ih) { // new Rectangle(bounds) or new Rectangle(x, y, w, h)\n    var x, x2, y, y2, w, h;\n\n    if(ix.x) {\n\t\tx = ix.x; y = ix.y;\t\n\t\t\tif(ix.w !== 0 && !ix.w && ix.x2){\n\t\t\t\tw = ix.x2-ix.x;\th = ix.y2-ix.y;\n\t\t\t}\telse {\n\t\t\t\tw = ix.w;\th = ix.h;\n\t\t\t}\n\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t} else {\n\t\tx = ix; y = iy;\tw = iw;\th = ih;\n\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t}\n\n\tthis.x1 = this.x = function(){return x;};\n\tthis.y1 = this.y = function(){return y;};\n\tthis.x2 = function(){return x2;};\n\tthis.y2 = function(){return y2;};\t\t\n\tthis.w = function(){return w;};\n\tthis.h = function(){return h;};\n\t\n\tthis.toJSON = function() {\n\t\treturn('{\"x\":'+x.toString()+', \"y\":'+y.toString()+', \"w\":'+w.toString()+', \"h\":'+h.toString()+'}');\n\t};\n\t\n\tthis.overlap = function(a) {\n\t\treturn(this.x() < a.x2() && this.x2() > a.x() && this.y() < a.y2() && this.y2() > a.y());\n\t};\n\t\n\tthis.expand = function(a) {\n\t\tvar nx = Math.min(this.x(), a.x());\n\t\tvar ny = Math.min(this.y(), a.y());\n\t\tw = Math.max(this.x2(), a.x2()) - nx;\n\t\th = Math.max(this.y2(), a.y2()) - ny;\n\t\tx = nx; y = ny;\n\t\treturn(this);\n\t};\n\t\n\tthis.setRect = function(ix, iy, iw, ih) {\n        var x, x2, y, y2, w, h;\n\t\tif(ix.x) {\n\t\t\tx = ix.x; y = ix.y;\t\n\t\t\tif(ix.w !== 0 && !ix.w && ix.x2) {\n\t\t\t\tw = ix.x2-ix.x;\th = ix.y2-ix.y;\n\t\t\t}\telse {\n\t\t\t\tw = ix.w;\th = ix.h;\n\t\t\t}\n\t\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t\t} else {\n\t\t\tx = ix; y = iy;\tw = iw;\th = ih;\n\t\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t\t}\n\t};\n//End of RTree.Rectangle\n};\n\n\n/* returns true if rectangle 1 overlaps rectangle 2\n * [ boolean ] = overlap_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.overlap_rectangle = function(a, b) {\n\treturn(a.x < (b.x+b.w) && (a.x+a.w) > b.x && a.y < (b.y+b.h) && (a.y+a.h) > b.y);\n};\n\n/* returns true if rectangle a is contained in rectangle b\n * [ boolean ] = contains_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.contains_rectangle = function(a, b) {\n\treturn((a.x+a.w) <= (b.x+b.w) && a.x >= b.x && (a.y+a.h) <= (b.y+b.h) && a.y >= b.y);\n};\n\n/* expands rectangle A to include rectangle B, rectangle B is untouched\n * [ rectangle a ] = expand_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.expand_rectangle = function(a, b)\t{\n\tvar nx = Math.min(a.x, b.x);\n\tvar ny = Math.min(a.y, b.y);\n\ta.w = Math.max(a.x+a.w, b.x+b.w) - nx;\n\ta.h = Math.max(a.y+a.h, b.y+b.h) - ny;\n\ta.x = nx; a.y = ny;\n\treturn(a);\n};\n\n/* generates a minimally bounding rectangle for all rectangles in\n * array \"nodes\". If rect is set, it is modified into the MBR. Otherwise,\n * a new rectangle is generated and returned.\n * [ rectangle a ] = make_MBR(rectangle array nodes, rectangle rect)\n * @static function\n */\nRTree.Rectangle.make_MBR = function(nodes, rect) {\n\tif(nodes.length < 1)\n\t\treturn({x:0, y:0, w:0, h:0});\n\t\t//throw \"make_MBR: nodes must contain at least one rectangle!\";\n\tif(!rect)\n\t\trect = {x:nodes[0].x, y:nodes[0].y, w:nodes[0].w, h:nodes[0].h};\n\telse\n\t\trect.x = nodes[0].x; rect.y = nodes[0].y; rect.w = nodes[0].w; rect.h = nodes[0].h;\n\t\t\n\tfor(var i = nodes.length-1; i>0; i--)\n\t\tRTree.Rectangle.expand_rectangle(rect, nodes[i]);\n\t\t\n\treturn(rect);\n};"]],"start1":0,"start2":0,"length1":0,"length2":24662}]],"length":24662,"saved":false}
