{"ts":1360933354524,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360933413248,"patch":[[{"diffs":[[1,"var hull = function(vertices) {\r\n  if (vertices.length < 3) return [];\r\n\r\n  var len = vertices.length,\r\n      plen = len - 1,\r\n      points = [],\r\n      stack = [],\r\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\r\n\r\n  // find the starting ref point: leftmost point with the minimum y coord\r\n  for (i=1; i<len; ++i) {\r\n    if (vertices[i][1] < vertices[h][1]) {\r\n      h = i;\r\n    } else if (vertices[i][1] == vertices[h][1]) {\r\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\r\n    }\r\n  }\r\n\r\n  // calculate polar angles from ref point and sort\r\n  for (i=0; i<len; ++i) {\r\n    if (i === h) continue;\r\n    y1 = vertices[i][1] - vertices[h][1];\r\n    x1 = vertices[i][0] - vertices[h][0];\r\n    points.push({angle: Math.atan2(y1, x1), index: i});\r\n  }\r\n  points.sort(function(a, b) { return a.angle - b.angle; });\r\n\r\n  // toss out duplicate angles\r\n  a = points[0].angle;\r\n  v = points[0].index;\r\n  u = 0;\r\n  for (i=1; i<plen; ++i) {\r\n    j = points[i].index;\r\n    if (a == points[i].angle) {\r\n      // keep angle for point most distant from the reference\r\n      x1 = vertices[v][0] - vertices[h][0];\r\n      y1 = vertices[v][1] - vertices[h][1];\r\n      x2 = vertices[j][0] - vertices[h][0];\r\n      y2 = vertices[j][1] - vertices[h][1];\r\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\r\n        points[i].index = -1;\r\n      } else {\r\n        points[u].index = -1;\r\n        a = points[i].angle;\r\n        u = i;\r\n        v = j;\r\n      }\r\n    } else {\r\n      a = points[i].angle;\r\n      u = i;\r\n      v = j;\r\n    }\r\n  }\r\n\r\n  // initialize the stack\r\n  stack.push(h);\r\n  for (i=0, j=0; i<2; ++j) {\r\n    if (points[j].index !== -1) {\r\n      stack.push(points[j].index);\r\n      i++;\r\n    }\r\n  }\r\n  sp = stack.length;\r\n\r\n  // do graham's scan\r\n  for (; j<plen; ++j) {\r\n    if (points[j].index === -1) continue; // skip tossed out points\r\n    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\r\n      --sp;\r\n    }\r\n    stack[sp++] = points[j].index;\r\n  }\r\n\r\n  // construct the hull\r\n  var poly = [];\r\n  for (i=0; i<sp; ++i) {\r\n    poly.push(vertices[stack[i]]);\r\n  }\r\n  return poly;\r\n}\r\n\r\n// are three points in counter-clockwise order?\r\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\r\n  var t, a, b, c, d, e, f;\r\n  t = v[i1]; a = t[0]; b = t[1];\r\n  t = v[i2]; c = t[0]; d = t[1];\r\n  t = v[i3]; e = t[0]; f = t[1];\r\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\r\n}\r\nvar  quadtree = function(points, x1, y1, x2, y2) {\r\n  var p,\r\n      i = -1,\r\n      n = points.length;\r\n\r\n  // Allow bounds to be specified explicitly.\r\n  if (arguments.length < 5) {\r\n    if (arguments.length === 3) {\r\n      y2 = y1;\r\n      x2 = x1;\r\n      y1 = x1 = 0;\r\n    } else {\r\n      x1 = y1 = Infinity;\r\n      x2 = y2 = -Infinity;\r\n\r\n      // Compute bounds.\r\n      while (++i < n) {\r\n        p = points[i];\r\n        if (p.x < x1) x1 = p.x;\r\n        if (p.y < y1) y1 = p.y;\r\n        if (p.x > x2) x2 = p.x;\r\n        if (p.y > y2) y2 = p.y;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Squarify the bounds.\r\n  var dx = x2 - x1,\r\n      dy = y2 - y1;\r\n  if (dx > dy) y2 = y1 + dx;\r\n  else x2 = x1 + dy;\r\n\r\n  // Recursively inserts the specified point p at the node n or one of its\r\n  // descendants. The bounds are defined by [x1, x2] and [y1, y2].\r\n  function insert(n, p, x1, y1, x2, y2) {\r\n    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points\r\n    if (n.leaf) {\r\n      var v = n.point;\r\n      if (v) {\r\n        // If the point at this leaf node is at the same position as the new\r\n        // point we are adding, we leave the point associated with the\r\n        // internal node while adding the new point to a child node. This\r\n        // avoids infinite recursion.\r\n        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {\r\n          insertChild(n, p, x1, y1, x2, y2);\r\n        } else {\r\n          n.point = null;\r\n          insertChild(n, v, x1, y1, x2, y2);\r\n          insertChild(n, p, x1, y1, x2, y2);\r\n        }\r\n      } else {\r\n        n.point = p;\r\n      }\r\n    } else {\r\n      insertChild(n, p, x1, y1, x2, y2);\r\n    }\r\n  }\r\n\r\n  // Recursively inserts the specified point p into a descendant of node n. The\r\n  // bounds are defined by [x1, x2] and [y1, y2].\r\n  function insertChild(n, p, x1, y1, x2, y2) {\r\n    // Compute the split point, and the quadrant in which to insert p.\r\n    var sx = (x1 + x2) * .5,\r\n        sy = (y1 + y2) * .5,\r\n        right = p.x >= sx,\r\n        bottom = p.y >= sy,\r\n        i = (bottom << 1) + right;\r\n\r\n    // Recursively insert into the child node.\r\n    n.leaf = false;\r\n    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\r\n\r\n    // Update the bounds as we recurse.\r\n    if (right) x1 = sx; else x2 = sx;\r\n    if (bottom) y1 = sy; else y2 = sy;\r\n    insert(n, p, x1, y1, x2, y2);\r\n  }\r\n\r\n  // Create the root node.\r\n  var root = d3_geom_quadtreeNode();\r\n\r\n  root.add = function(p) {\r\n    insert(root, p, x1, y1, x2, y2);\r\n  };\r\n\r\n  root.visit = function(f) {\r\n    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\r\n  };\r\n\r\n  // Insert all points.\r\n  points.forEach(root.add);\r\n  return root;\r\n};\r\n\r\nfunction d3_geom_quadtreeNode() {\r\n  return {\r\n    leaf: true,\r\n    nodes: [],\r\n    point: null\r\n  };\r\n}\r\n\r\nfunction d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\r\n  if (!f(node, x1, y1, x2, y2)) {\r\n    var sx = (x1 + x2) * .5,\r\n        sy = (y1 + y2) * .5,\r\n        children = node.nodes;\r\n    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\r\n    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\r\n    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\r\n    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\r\n  }\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":5645}]],"length":5645,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360938880181,"patch":[[{"diffs":[[0," 0;\r\n}\r\n"],[1,"\r\nfunction Quadtree(points){\r\n    "],[0,"var  qua"]],"start1":2369,"start2":2369,"length1":16,"length2":50},{"diffs":[[0,"\r\n  }\r\n}"],[1,"\r\n    \r\n    \r\nthis.quadtree = quadtree(points.map(function(v){return {x:v[0],y:v[1]};}));\r\n\r\n\r\nthis.bbox=function(blat1,blng1,blat2,blng2){\r\n    var out = [];\r\n    this.quadtree.visit(function(quad, lat1, lng1, lat2, lng2){\r\n      if(((blat1>lat2)&&(blat2>lat2))||((blat1<lat1)&&(blat2<lat1))||((blng1>lng2)&&(blng2>lng2))||((blng1<lng1)&&(blng2<lng1))){\r\n     \r\n       return true;\r\n       }else if(((blat2>=lat2)&&(blng2>=lng2)&&(blat1<=lat1)&&(blng1<=lng1))){\r\n       out.push(quad);\r\n       return true;\r\n       }\r\n        });\r\n        var pts = [];\r\n        function getPt(quad){\r\n            if(quad.point){\r\n                pts.push([quad.point.x,quad.point.y])\r\n            }\r\n            if(!quad.leaf&&quad.nodes.length>0){\r\n                quad.nodes.forEach(getPt);\r\n            }\r\n        }\r\n        out.forEach(getPt);\r\n        return pts;\r\n}\r\n}"]],"start1":5671,"start2":5671,"length1":8,"length2":867}]],"length":6538,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360943176908,"patch":[[{"diffs":[[0,"nction(v"],[1,",i"],[0,"){return"]],"start1":5731,"start2":5731,"length1":16,"length2":18},{"diffs":[[0,"],y:v[1]"],[1,",id:i"],[0,"};}));\r\n"]],"start1":5756,"start2":5756,"length1":16,"length2":21}]],"length":6545,"saved":false}
{"ts":1360943258156,"patch":[[{"diffs":[[0,".point.y"],[1,",quad.point.id"],[0,"])\r\n    "]],"start1":6344,"start2":6344,"length1":16,"length2":30}]],"length":6559,"saved":false}
{"ts":1360945165200,"patch":[[{"diffs":[[0,"[1],"],[-1,"id:i"],[1,"all:v"],[0,"};}));\r\n"],[1,"this.add = function(pts){\r\n    this.quadtree.add\r\n};"],[0,"\r\n\r\n"]],"start1":5761,"start2":5761,"length1":20,"length2":73},{"diffs":[[0,"ts.push("],[-1,"["],[0,"quad.poi"]],"start1":6371,"start2":6371,"length1":17,"length2":16},{"diffs":[[0,"int."],[-1,"x,quad.point.y,quad.point.id]"],[1,"all"],[0,")\r\n "]],"start1":6386,"start2":6386,"length1":37,"length2":11}]],"length":6585,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360986183518,"patch":[[{"diffs":[[0,"n pts;\r\n}\r\n}"],[1,"\r\nDistanceGrid = function (cellSize) {\r\n    this._cellSize = cellSize;\r\n\tthis._sqCellSize = cellSize * cellSize;\r\n\tthis._grid = {};\r\n\tthis._objectPoint = { };\r\n};\r\n\r\nDistanceGrid.prototype = {\r\n\r\n\taddObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    stamp = makeStamp(obj);\r\n\r\n\t\tthis._objectPoint[stamp] = point;\r\n\r\n\t\tcell.push(obj);\r\n\t},\r\n\r\n\tupdateObject: function (obj, point) {\r\n\t\tthis.removeObject(obj);\r\n\t\tthis.addObject(obj, point);\r\n\t},\r\n\r\n\t//Returns true if the object was found\r\n\tremoveObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    i, len;\r\n\r\n\t\tdelete this._objectPoint[makeStamp(obj)];\r\n\r\n\t\tfor (i = 0, len = cell.length; i < len; i++) {\r\n\t\t\tif (cell[i] === obj) {\r\n\r\n\t\t\t\tcell.splice(i, 1);\r\n\r\n\t\t\t\tif (len === 1) {\r\n\t\t\t\t\tdelete row[x];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t},\r\n\r\n\teachObject: function (fn, context) {\r\n\t\tvar i, j, k, len, row, cell, removed,\r\n\t\t    grid = this._grid;\r\n\r\n\t\tfor (i in grid) {\r\n\t\t\tif (grid.hasOwnProperty(i)) {\r\n\t\t\t\trow = grid[i];\r\n\r\n\t\t\t\tfor (j in row) {\r\n\t\t\t\t\tif (row.hasOwnProperty(j)) {\r\n\t\t\t\t\t\tcell = row[j];\r\n\r\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\r\n\t\t\t\t\t\t\tif (removed) {\r\n\t\t\t\t\t\t\t\tk--;\r\n\t\t\t\t\t\t\t\tlen--;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetNearObject: function (point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    i, j, k, row, cell, len, obj, dist,\r\n\t\t    objectPoint = this._objectPoint,\r\n\t\t    closestDistSq = this._sqCellSize,\r\n\t\t    closest = null;\r\n\r\n\t\tfor (i = y - 1; i <= y + 1; i++) {\r\n\t\t\trow = this._grid[i];\r\n\t\t\tif (row) {\r\n\r\n\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\r\n\t\t\t\t\tcell = row[j];\r\n\t\t\t\t\tif (cell) {\r\n\r\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\t\t\tobj = cell[k];\r\n\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[makeStamp(obj)], point);\r\n\t\t\t\t\t\t\tif (dist < closestDistSq) {\r\n\t\t\t\t\t\t\t\tclosestDistSq = dist;\r\n\t\t\t\t\t\t\t\tclosest = obj;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t},\r\n\r\n\t_getCoord: function (x) {\r\n\t\treturn Math.floor(x / this._cellSize);\r\n\t},\r\n\r\n\t_sqDist: function (p, p2) {\r\n\t\tvar dx = p2.x - p.x,\r\n\t\t    dy = p2.y - p.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t}\r\n};"]],"start1":6573,"start2":6573,"length1":12,"length2":2516}]],"length":9089,"saved":false}
{"ts":1360986200997,"patch":[[{"diffs":[[0,"\r\n}\r\n}\r\n"],[1,"makeStamp(obj){\r\n    var shaObj = new jsSHA(JSON.stringify(obj), \"TEXT\");\r\n    return parseInt(shaObj.getHash(\"SHA-1\", \"HEX\").slice(0,10),16)\r\n}\r\nvar "],[0,"Distance"]],"start1":6579,"start2":6579,"length1":16,"length2":166}]],"length":9239,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361048359388,"patch":[[{"diffs":[[-1,"var hull = function(vertices) {\r\n  if (vertices.length < 3) return [];\r\n\r\n  var len = vertices.length,\r\n      plen = len - 1,\r\n      points = [],\r\n      stack = [],\r\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\r\n\r\n  // find the starting ref point: leftmost point with the minimum y coord\r\n  for (i=1; i<len; ++i) {\r\n    if (vertices[i][1] < vertices[h][1]) {\r\n      h = i;\r\n    } else if (vertices[i][1] == vertices[h][1]) {\r\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\r\n    }\r\n  }\r\n\r\n  // calculate polar angles from ref point and sort\r\n  for (i=0; i<len; ++i) {\r\n    if (i === h) continue;\r\n    y1 = vertices[i][1] - vertices[h][1];\r\n    x1 = vertices[i][0] - vertices[h][0];\r\n    points.push({angle: Math.atan2(y1, x1), index: i});\r\n  }\r\n  points.sort(function(a, b) { return a.angle - b.angle; });\r\n\r\n  // toss out duplicate angles\r\n  a = points[0].angle;\r\n  v = points[0].index;\r\n  u = 0;\r\n  for (i=1; i<plen; ++i) {\r\n    j = points[i].index;\r\n    if (a == points[i].angle) {\r\n      // keep angle for point most distant from the reference\r\n      x1 = vertices[v][0] - vertices[h][0];\r\n      y1 = vertices[v][1] - vertices[h][1];\r\n      x2 = vertices[j][0] - vertices[h][0];\r\n      y2 = vertices[j][1] - vertices[h][1];\r\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\r\n        points[i].index = -1;\r\n      } else {\r\n        points[u].index = -1;\r\n        a = points[i].angle;\r\n        u = i;\r\n        v = j;\r\n      }\r\n    } else {\r\n      a = points[i].angle;\r\n      u = i;\r\n      v = j;\r\n    }\r\n  }\r\n\r\n  // initialize the stack\r\n  stack.push(h);\r\n  for (i=0, j=0; i<2; ++j) {\r\n    if (points[j].index !== -1) {\r\n      stack.push(points[j].index);\r\n      i++;\r\n    }\r\n  }\r\n  sp = stack.length;\r\n\r\n  // do graham's scan\r\n  for (; j<plen; ++j) {\r\n    if (points[j].index === -1) continue; // skip tossed out points\r\n    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\r\n      --sp;\r\n    }\r\n    stack[sp++] = points[j].index;\r\n  }\r\n\r\n  // construct the hull\r\n  var poly = [];\r\n  for (i=0; i<sp; ++i) {\r\n    poly.push(vertices[stack[i]]);\r\n  }\r\n  return poly;\r\n}\r\n\r\n// are three points in counter-clockwise order?\r\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\r\n  var t, a, b, c, d, e, f;\r\n  t = v[i1]; a = t[0]; b = t[1];\r\n  t = v[i2]; c = t[0]; d = t[1];\r\n  t = v[i3]; e = t[0]; f = t[1];\r\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\r\n}"],[0,"\r\n\r\n"]],"start1":0,"start2":0,"length1":2379,"length2":4}]],"length":6864,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361198773458,"patch":[[{"diffs":[[-1,"\r\n\r\nfunction Quadtree(points){\r\n    var  quadtree = function(points, x1, y1, x2, y2) {\r\n  var p,\r\n      i = -1,\r\n      n = points.length;\r\n\r\n  // Allow bounds to be specified explicitly.\r\n  if (arguments.length < 5) {\r\n    if (arguments.length === 3) {\r\n      y2 = y1;\r\n      x2 = x1;\r\n      y1 = x1 = 0;\r\n    } else {\r\n      x1 = y1 = Infinity;\r\n      x2 = y2 = -Infinity;\r\n\r\n      // Compute bounds.\r\n      while (++i < n) {\r\n        p = points[i];\r\n        if (p.x < x1) x1 = p.x;\r\n        if (p.y < y1) y1 = p.y;\r\n        if (p.x > x2) x2 = p.x;\r\n        if (p.y > y2) y2 = p.y;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Squarify the bounds.\r\n  var dx = x2 - x1,\r\n      dy = y2 - y1;\r\n  if (dx > dy) y2 = y1 + dx;\r\n  else x2 = x1 + dy;\r\n\r\n  // Recursively inserts the specified point p at the node n or one of its\r\n  // descendants. The bounds are defined by [x1, x2] and [y1, y2].\r\n  function insert(n, p, x1, y1, x2, y2) {\r\n    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points\r\n    if (n.leaf) {\r\n      var v = n.point;\r\n      if (v) {\r\n        // If the point at this leaf node is at the same position as the new\r\n        // point we are adding, we leave the point associated with the\r\n        // internal node while adding the new point to a child node. This\r\n        // avoids infinite recursion.\r\n        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {\r\n          insertChild(n, p, x1, y1, x2, y2);\r\n        } else {\r\n          n.point = null;\r\n          insertChild(n, v, x1, y1, x2, y2);\r\n          insertChild(n, p, x1, y1, x2, y2);\r\n        }\r\n      } else {\r\n        n.point = p;\r\n      }\r\n    } else {\r\n      insertChild(n, p, x1, y1, x2, y2);\r\n    }\r\n  }\r\n\r\n  // Recursively inserts the specified point p into a descendant of node n. The\r\n  // bounds are defined by [x1, x2] and [y1, y2].\r\n  function insertChild(n, p, x1, y1, x2, y2) {\r\n    // Compute the split point, and the quadrant in which to insert p.\r\n    var sx = (x1 + x2) * .5,\r\n        sy = (y1 + y2) * .5,\r\n        right = p.x >= sx,\r\n        bottom = p.y >= sy,\r\n        i = (bottom << 1) + right;\r\n\r\n    // Recursively insert into the child node.\r\n    n.leaf = false;\r\n    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\r\n\r\n    // Update the bounds as we recurse.\r\n    if (right) x1 = sx; else x2 = sx;\r\n    if (bottom) y1 = sy; else y2 = sy;\r\n    insert(n, p, x1, y1, x2, y2);\r\n  }\r\n\r\n  // Create the root node.\r\n  var root = d3_geom_quadtreeNode();\r\n\r\n  root.add = function(p) {\r\n    insert(root, p, x1, y1, x2, y2);\r\n  };\r\n\r\n  root.visit = function(f) {\r\n    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\r\n  };\r\n\r\n  // Insert all points.\r\n  points.forEach(root.add);\r\n  return root;\r\n};\r\n\r\nfunction d3_geom_quadtreeNode() {\r\n  return {\r\n    leaf: true,\r\n    nodes: [],\r\n    point: null\r\n  };\r\n}\r\n\r\nfunction d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\r\n  if (!f(node, x1, y1, x2, y2)) {\r\n    var sx = (x1 + x2) * .5,\r\n        sy = (y1 + y2) * .5,\r\n        children = node.nodes;\r\n    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\r\n    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\r\n    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\r\n    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\r\n  }\r\n}\r\n    \r\n    \r\nthis.quadtree = quadtree(points.map(function(v,i){return {x:v[0],y:v[1],all:v};}));\r\nthis.add = function(pts){\r\n    this.quadtree.add\r\n};\r\n\r\nthis.bbox=function(blat1,blng1,blat2,blng2){\r\n    var out = [];\r\n    this.quadtree.visit(function(quad, lat1, lng1, lat2, lng2){\r\n      if(((blat1>lat2)&&(blat2>lat2))||((blat1<lat1)&&(blat2<lat1))||((blng1>lng2)&&(blng2>lng2))||((blng1<lng1)&&(blng2<lng1))){\r\n     \r\n       return true;\r\n       }else if(((blat2>=lat2)&&(blng2>=lng2)&&(blat1<=lat1)&&(blng1<=lng1))){\r\n       out.push(quad);\r\n       return true;\r\n       }\r\n        });\r\n        var pts = [];\r\n        function getPt(quad){\r\n            if(quad.point){\r\n                pts.push(quad.point.all)\r\n            }\r\n            if(!quad.leaf&&quad.nodes.length>0){\r\n                quad.nodes.forEach(getPt);\r\n            }\r\n        }\r\n        out.forEach(getPt);\r\n        return pts;\r\n}\r\n}\r\nmakeStamp(obj){\r\n    var shaObj = new jsSHA(JSON.stringify(obj), \"TEXT\");\r\n    return parseInt(shaObj.getHash(\"SHA-1\", \"HEX\").slice(0,10),16)\r\n}\r\nvar DistanceGrid = function (cellSize) {\r\n    this._cellSize = cellSize;\r\n\tthis._sqCellSize = cellSize * cellSize;\r\n\tthis._grid = {};\r\n\tthis._objectPoint = { };\r\n};\r\n\r\nDistanceGrid.prototype = {\r\n\r\n\taddObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    stamp = makeStamp(obj);\r\n\r\n\t\tthis._objectPoint[stamp] = point;\r\n\r\n\t\tcell.push(obj);\r\n\t},\r\n\r\n\tupdateObject: function (obj, point) {\r\n\t\tthis.removeObject(obj);\r\n\t\tthis.addObject(obj, point);\r\n\t},\r\n\r\n\t//Returns true if the object was found\r\n\tremoveObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    i, len;\r\n\r\n\t\tdelete this._objectPoint[makeStamp(obj)];\r\n\r\n\t\tfor (i = 0, len = cell.length; i < len; i++) {\r\n\t\t\tif (cell[i] === obj) {\r\n\r\n\t\t\t\tcell.splice(i, 1);\r\n\r\n\t\t\t\tif (len === 1) {\r\n\t\t\t\t\tdelete row[x];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t},\r\n\r\n\teachObject: function (fn, context) {\r\n\t\tvar i, j, k, len, row, cell, removed,\r\n\t\t    grid = this._grid;\r\n\r\n\t\tfor (i in grid) {\r\n\t\t\tif (grid.hasOwnProperty(i)) {\r\n\t\t\t\trow = grid[i];\r\n\r\n\t\t\t\tfor (j in row) {\r\n\t\t\t\t\tif (row.hasOwnProperty(j)) {\r\n\t\t\t\t\t\tcell = row[j];\r\n\r\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\r\n\t\t\t\t\t\t\tif (removed) {\r\n\t\t\t\t\t\t\t\tk--;\r\n\t\t\t\t\t\t\t\tlen--;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetNearObject: function (point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    i, j, k, row, cell, len, obj, dist,\r\n\t\t    objectPoint = this._objectPoint,\r\n\t\t    closestDistSq = this._sqCellSize,\r\n\t\t    closest = null;\r\n\r\n\t\tfor (i = y - 1; i <= y + 1; i++) {\r\n\t\t\trow = this._grid[i];\r\n\t\t\tif (row) {\r\n\r\n\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\r\n\t\t\t\t\tcell = row[j];\r\n\t\t\t\t\tif (cell) {\r\n\r\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\t\t\tobj = cell[k];\r\n\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[makeStamp(obj)], point);\r\n\t\t\t\t\t\t\tif (dist < closestDistSq) {\r\n\t\t\t\t\t\t\t\tclosestDistSq = dist;\r\n\t\t\t\t\t\t\t\tclosest = obj;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t},\r\n\r\n\t_getCoord: function (x) {\r\n\t\treturn Math.floor(x / this._cellSize);\r\n\t},\r\n\r\n\t_sqDist: function (p, p2) {\r\n\t\tvar dx = p2.x - p.x,\r\n\t\t    dy = p2.y - p.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t}\r"],[1,"//from d3\nvar centroid = function(coords){\nfunction d3_number(x) {\n  return x != null && !isNaN(x);\n}\nvar mean = function(array, f) {\n  var n = array.length,\n      a,\n      m = 0,\n      i = -1,\n      j = 0;\n  if (arguments.length === 1) {\n    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\n  } else {\n    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\n  }\n  return j ? m : undefined;\n};\n\nreturn [mean(coords,function(v){return v[0]}),mean(coords,function(v){return v[1]})]\n\n}\n\n//from d3\nvar hull = function(vertices) {\n  if (vertices.length < 3) return [];\n\n  var len = vertices.length,\n      plen = len - 1,\n      points = [],\n      stack = [],\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\n\n  // find the starting ref point: leftmost point with the minimum y coord\n  for (i=1; i<len; ++i) {\n    if (vertices[i][1] < vertices[h][1]) {\n      h = i;\n    } else if (vertices[i][1] == vertices[h][1]) {\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\n    }\n  }\n\n  // calculate polar angles from ref point and sort\n  for (i=0; i<len; ++i) {\n    if (i === h) continue;\n    y1 = vertices[i][1] - vertices[h][1];\n    x1 = vertices[i][0] - vertices[h][0];\n    points.push({angle: Math.atan2(y1, x1), index: i});\n  }\n  points.sort(function(a, b) { return a.angle - b.angle; });\n\n  // toss out duplicate angles\n  a = points[0].angle;\n  v = points[0].index;\n  u = 0;\n  for (i=1; i<plen; ++i) {\n    j = points[i].index;\n    if (a == points[i].angle) {\n      // keep angle for point most distant from the reference\n      x1 = vertices[v][0] - vertices[h][0];\n      y1 = vertices[v][1] - vertices[h][1];\n      x2 = vertices[j][0] - vertices[h][0];\n      y2 = vertices[j][1] - vertices[h][1];\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\n        points[i].index = -1;\n      } else {\n        points[u].index = -1;\n        a = points[i].angle;\n        u = i;\n        v = j;\n      }\n    } else {\n      a = points[i].angle;\n      u = i;\n      v = j;\n    }\n  }\n\n  // initialize the stack\n  stack.push(h);\n  for (i=0, j=0; i<2; ++j) {\n    if (points[j].index !== -1) {\n      stack.push(points[j].index);\n      i++;\n    }\n  }\n  sp = stack.length;\n\n  // do graham's scan\n  for (; j<plen; ++j) {\n    if (points[j].index === -1) continue; // skip tossed out points\n    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\n      --sp;\n    }\n    stack[sp++] = points[j].index;\n  }\n\n  // construct the hull\n  var poly = [];\n  for (i=0; i<sp; ++i) {\n    poly.push(vertices[stack[i]]);\n  }\n  return poly;\n}\n\n// are three points in counter-clockwise order?\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\n  var t, a, b, c, d, e, f;\n  t = v[i1]; a = t[0]; b = t[1];\n  t = v[i2]; c = t[0]; d = t[1];\n  t = v[i3]; e = t[0]; f = t[1];\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\n}\n\n/****************************************************************************** \n    rtree.js - General-Purpose Non-Recursive Javascript R-Tree Library\n    Version 0.6.2, December 5st 2009\n\n  Copyright (c) 2009 Jon-Carlos Rivera\n  \n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n  \n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    Jon-Carlos Rivera - imbcmdth@hotmail.com\n******************************************************************************/\n\n/**\n * RTree - A simple r-tree structure for great results.\n * @constructor\n */\nvar RTree = function(width){\n\t// Variables to control tree-dimensions\n\tvar _Min_Width = 3;  // Minimum width of any node before a merge\n\tvar _Max_Width = 6;  // Maximum width of any node before a split\n\tif(!isNaN(width)){ _Min_Width = Math.floor(width/2.0); _Max_Width = width;}\n\t// Start with an empty root-tree\n\tvar _T = {x:0, y:0, w:0, h:0, id:\"root\", nodes:[] };\n    \n\tvar isArray = function(o) {\n\t\treturn Object.prototype.toString.call(o) === '[object Array]'; \n\t};\n\n\t/* @function\n\t * @description Function to generate unique strings for element IDs\n\t * @param {String} n\t\t\tThe prefix to use for the IDs generated.\n\t * @return {String}\t\t\t\tA guarenteed unique ID.\n\t */\n    var _name_to_id = (function() {\n        // hide our idCache inside this closure\n        var idCache = {};\n\n        // return the api: our function that returns a unique string with incrementing number appended to given idPrefix\n        return function(idPrefix) {\n            var idVal = 0;\n            if(idPrefix in idCache) {\n                idVal = idCache[idPrefix]++;\n            } else {\n                idCache[idPrefix] = 0;\n            }\n            return idPrefix + \"_\" + idVal;\n        }\n    })();\n\n\t// This is my special addition to the world of r-trees\n\t// every other (simple) method I found produced crap trees\n\t// this skews insertions to prefering squarer and emptier nodes\n\tRTree.Rectangle.squarified_ratio = function(l, w, fill) {\n\t  // Area of new enlarged rectangle\n\t  var lperi = (l + w) / 2.0; // Average size of a side of the new rectangle\n\t  var larea = l * w; // Area of new rectangle\n\t  // return the ratio of the perimeter to the area - the closer to 1 we are, \n\t  // the more \"square\" a rectangle is. conversly, when approaching zero the \n\t  // more elongated a rectangle is\n\t  var lgeo = larea / (lperi*lperi);\n\t  return(larea * fill / lgeo); \n\t};\n\t\n\t/* find the best specific node(s) for object to be deleted from\n\t * [ leaf node parent ] = _remove_subtree(rectangle, object, root)\n\t * @private\n\t */\n\tvar _remove_subtree = function(rect, obj, root) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\tvar count_stack = []; // Contains the elements that overlap\n\t\tvar ret_array = [];\n\t\tvar current_depth = 1;\n\t\t\n\t\tif(!rect || !RTree.Rectangle.overlap_rectangle(rect, root))\n\t\t return ret_array;\n\n\t\tvar ret_obj = {x:rect.x, y:rect.y, w:rect.w, h:rect.h, target:obj};\n\t\t\n\t\tcount_stack.push(root.nodes.length);\n\t\thit_stack.push(root);\n\n\t\tdo {\n\t\t\tvar tree = hit_stack.pop();\n\t\t\tvar i = count_stack.pop()-1;\n\t\t\t\n\t\t  if(\"target\" in ret_obj) { // We are searching for a target\n\t\t\t\twhile(i >= 0)\t{\n\t\t\t\t\tvar ltree = tree.nodes[i];\n\t\t\t\t\tif(RTree.Rectangle.overlap_rectangle(ret_obj, ltree)) {\n\t\t\t\t\t\tif( (ret_obj.target && \"leaf\" in ltree && ltree.leaf === ret_obj.target)\n\t\t\t\t\t\t\t||(!ret_obj.target && (\"leaf\" in ltree || RTree.Rectangle.contains_rectangle(ltree, ret_obj)))) { // A Match !!\n\t\t\t\t  \t\t// Yup we found a match...\n\t\t\t\t  \t\t// we can cancel search and start walking up the list\n\t\t\t\t  \t\tif(\"nodes\" in ltree) {// If we are deleting a node not a leaf...\n\t\t\t\t  \t\t\tret_array = _search_subtree(ltree, true, [], ltree);\n\t\t\t\t  \t\t\ttree.nodes.splice(i, 1); \n\t\t\t\t  \t\t} else {\n\t\t\t\t\t\t\t\tret_array = tree.nodes.splice(i, 1); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Resize MBR down...\n\t\t\t\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t\t\t\t\tdelete ret_obj.target;\n\t\t\t\t\t\t\tif(tree.nodes.length < _Min_Width) { // Underflow\n\t\t\t\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, [], tree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t  \t\t}/*\telse if(\"load\" in ltree) { // A load\n\t\t\t\t  \t}*/\telse if(\"nodes\" in ltree) { // Not a Leaf\n\t\t\t\t  \t\tcurrent_depth += 1;\n\t\t\t\t  \t\tcount_stack.push(i);\n\t\t\t\t  \t\thit_stack.push(tree);\n\t\t\t\t  \t\ttree = ltree;\n\t\t\t\t  \t\ti = ltree.nodes.length;\n\t\t\t\t  \t}\n\t\t\t\t  }\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t} else if(\"nodes\" in ret_obj) { // We are unsplitting\n\t\t\t\ttree.nodes.splice(i+1, 1); // Remove unsplit node\n\t\t\t\t// ret_obj.nodes contains a list of elements removed from the tree so far\n\t\t\t\tif(tree.nodes.length > 0)\n\t\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t\tfor(var t = 0;t<ret_obj.nodes.length;t++)\n\t\t\t\t\t_insert_subtree(ret_obj.nodes[t], tree);\n\t\t\t\tret_obj.nodes.length = 0;\n\t\t\t\tif(hit_stack.length == 0 && tree.nodes.length <= 1) { // Underflow..on root!\n\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);\n\t\t\t\t\ttree.nodes.length = 0;\n\t\t\t\t\thit_stack.push(tree);\n\t\t\t\t\tcount_stack.push(1);\n\t\t\t\t} else if(hit_stack.length > 0 && tree.nodes.length < _Min_Width) { // Underflow..AGAIN!\n\t\t\t\t\tret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);\n\t\t\t\t\ttree.nodes.length = 0;\t\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tdelete ret_obj.nodes; // Just start resizing\n\t\t\t\t}\n\t\t\t} else { // we are just resizing\n\t\t\t\tRTree.Rectangle.make_MBR(tree.nodes, tree);\n\t\t\t}\n\t\t\tcurrent_depth -= 1;\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn(ret_array);\n\t};\n\n\t/* choose the best damn node for rectangle to be inserted into\n\t * [ leaf node parent ] = _choose_leaf_subtree(rectangle, root to start search at)\n\t * @private\n\t */\n\tvar _choose_leaf_subtree = function(rect, root) {\n\t\tvar best_choice_index = -1;\n\t\tvar best_choice_stack = [];\n\t\tvar best_choice_area;\n\t\t\n\t\tvar load_callback = function(local_tree, local_node){\n\t\t\treturn(function(data) { \n\t\t\t\tlocal_tree._attach_data(local_node, data);\n\t\t\t});\n\t\t};\n\t\n\t\tbest_choice_stack.push(root);\n\t\tvar nodes = root.nodes;\t\n\n\t\tdo {\t\n\t\t\tif(best_choice_index != -1)\t{\n\t\t\t\tbest_choice_stack.push(nodes[best_choice_index]);\n\t\t\t\tnodes = nodes[best_choice_index].nodes;\n\t\t\t\tbest_choice_index = -1;\n\t\t\t}\n\t\n\t\t\tfor(var i = nodes.length-1; i >= 0; i--) {\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t\tif(\"leaf\" in ltree) {  \n\t\t\t\t\t// Bail out of everything and start inserting\n\t\t\t\t\tbest_choice_index = -1;\n\t\t\t\t\tbreak;\n\t\t\t  } /*else if(ltree.load) {\n  \t\t\t\tthrow( \"Can't insert into partially loaded tree ... yet!\");\n  \t\t\t\t//jQuery.getJSON(ltree.load, load_callback(this, ltree));\n  \t\t\t\t//delete ltree.load;\n  \t\t\t}*/\n\t\t\t  // Area of new enlarged rectangle\n\t\t\t  var old_lratio = RTree.Rectangle.squarified_ratio(ltree.w, ltree.h, ltree.nodes.length+1);\n\n\t\t\t  // Enlarge rectangle to fit new rectangle\n\t\t\t  var nw = Math.max(ltree.x+ltree.w, rect.x+rect.w) - Math.min(ltree.x, rect.x);\n\t\t\t  var nh = Math.max(ltree.y+ltree.h, rect.y+rect.h) - Math.min(ltree.y, rect.y);\n\t\t\t  \n\t\t\t  // Area of new enlarged rectangle\n\t\t\t  var lratio = RTree.Rectangle.squarified_ratio(nw, nh, ltree.nodes.length+2);\n\t\t\t  \n\t\t\t  if(best_choice_index < 0 || Math.abs(lratio - old_lratio) < best_choice_area) {\n\t\t\t  \tbest_choice_area = Math.abs(lratio - old_lratio); best_choice_index = i;\n\t\t\t  }\n\t\t\t}\n\t\t}while(best_choice_index != -1);\n\n\t\treturn(best_choice_stack);\n\t};\n\n\t/* split a set of nodes into two roughly equally-filled nodes\n\t * [ an array of two new arrays of nodes ] = linear_split(array of nodes)\n\t * @private\n\t */\n\tvar _linear_split = function(nodes) {\n\t\tvar n = _pick_linear(nodes);\n\t\twhile(nodes.length > 0)\t{\n\t\t\t_pick_next(nodes, n[0], n[1]);\n\t\t}\n\t\treturn(n);\n\t};\n\t\n\t/* insert the best source rectangle into the best fitting parent node: a or b\n\t * [] = pick_next(array of source nodes, target node array a, target node array b)\n\t * @private\n\t */\n\tvar _pick_next = function(nodes, a, b) {\n\t  // Area of new enlarged rectangle\n\t\tvar area_a = RTree.Rectangle.squarified_ratio(a.w, a.h, a.nodes.length+1);\n\t\tvar area_b = RTree.Rectangle.squarified_ratio(b.w, b.h, b.nodes.length+1);\n\t\tvar high_area_delta;\n\t\tvar high_area_node;\n\t\tvar lowest_growth_group;\n\t\t\n\t\tfor(var i = nodes.length-1; i>=0;i--) {\n\t\t\tvar l = nodes[i];\n\t\t\tvar new_area_a = {};\n\t\t\tnew_area_a.x = Math.min(a.x, l.x); new_area_a.y = Math.min(a.y, l.y);\n\t\t\tnew_area_a.w = Math.max(a.x+a.w, l.x+l.w) - new_area_a.x;\tnew_area_a.h = Math.max(a.y+a.h, l.y+l.h) - new_area_a.y;\n\t\t\tvar change_new_area_a = Math.abs(RTree.Rectangle.squarified_ratio(new_area_a.w, new_area_a.h, a.nodes.length+2) - area_a);\n\t\n\t\t\tvar new_area_b = {};\n\t\t\tnew_area_b.x = Math.min(b.x, l.x); new_area_b.y = Math.min(b.y, l.y);\n\t\t\tnew_area_b.w = Math.max(b.x+b.w, l.x+l.w) - new_area_b.x;\tnew_area_b.h = Math.max(b.y+b.h, l.y+l.h) - new_area_b.y;\n\t\t\tvar change_new_area_b = Math.abs(RTree.Rectangle.squarified_ratio(new_area_b.w, new_area_b.h, b.nodes.length+2) - area_b);\n\n\t\t\tif( !high_area_node || !high_area_delta || Math.abs( change_new_area_b - change_new_area_a ) < high_area_delta ) {\n\t\t\t\thigh_area_node = i;\n\t\t\t\thigh_area_delta = Math.abs(change_new_area_b-change_new_area_a);\n\t\t\t\tlowest_growth_group = change_new_area_b < change_new_area_a ? b : a;\n\t\t\t}\n\t\t}\n\t\tvar temp_node = nodes.splice(high_area_node, 1)[0];\n\t\tif(a.nodes.length + nodes.length + 1 <= _Min_Width)\t{\n\t\t\ta.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(a, temp_node);\n\t\t}\telse if(b.nodes.length + nodes.length + 1 <= _Min_Width) {\n\t\t\tb.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(b, temp_node);\n\t\t}\n\t\telse {\n\t\t\tlowest_growth_group.nodes.push(temp_node);\n\t\t\tRTree.Rectangle.expand_rectangle(lowest_growth_group, temp_node);\n\t\t}\n\t};\n\n\t/* pick the \"best\" two starter nodes to use as seeds using the \"linear\" criteria\n\t * [ an array of two new arrays of nodes ] = pick_linear(array of source nodes)\n\t * @private\n\t */\n\tvar _pick_linear = function(nodes) {\n\t\tvar lowest_high_x = nodes.length-1;\n\t\tvar highest_low_x = 0;\n\t\tvar lowest_high_y = nodes.length-1;\n\t\tvar highest_low_y = 0;\n        var t1, t2;\n\t\t\n\t\tfor(var i = nodes.length-2; i>=0;i--)\t{\n\t\t\tvar l = nodes[i];\n\t\t\tif(l.x > nodes[highest_low_x].x ) highest_low_x = i;\n\t\t\telse if(l.x+l.w < nodes[lowest_high_x].x+nodes[lowest_high_x].w) lowest_high_x = i;\n\t\t\tif(l.y > nodes[highest_low_y].y ) highest_low_y = i;\n\t\t\telse if(l.y+l.h < nodes[lowest_high_y].y+nodes[lowest_high_y].h) lowest_high_y = i;\n\t\t}\n\t\tvar dx = Math.abs((nodes[lowest_high_x].x+nodes[lowest_high_x].w) - nodes[highest_low_x].x);\n\t\tvar dy = Math.abs((nodes[lowest_high_y].y+nodes[lowest_high_y].h) - nodes[highest_low_y].y);\n\t\tif( dx > dy )\t{ \n\t\t\tif(lowest_high_x > highest_low_x)\t{\n\t\t\t\tt1 = nodes.splice(lowest_high_x, 1)[0];\n\t\t\t\tt2 = nodes.splice(highest_low_x, 1)[0];\n\t\t\t}\telse {\n\t\t\t\tt2 = nodes.splice(highest_low_x, 1)[0];\n\t\t\t\tt1 = nodes.splice(lowest_high_x, 1)[0];\n\t\t\t}\n\t\t}\telse {\n\t\t\tif(lowest_high_y > highest_low_y)\t{\n\t\t\t\tt1 = nodes.splice(lowest_high_y, 1)[0];\n\t\t\t\tt2 = nodes.splice(highest_low_y, 1)[0];\n\t\t\t}\telse {\n\t\t\t\tt2 = nodes.splice(highest_low_y, 1)[0];\n\t\t\t\tt1 = nodes.splice(lowest_high_y, 1)[0];\n\t\t\t}\n\t\t}\n\t\treturn([{x:t1.x, y:t1.y, w:t1.w, h:t1.h, nodes:[t1]},\n\t\t\t      {x:t2.x, y:t2.y, w:t2.w, h:t2.h, nodes:[t2]} ]);\n\t};\n\t\n\tvar _attach_data = function(node, more_tree){\n\t\tnode.nodes = more_tree.nodes;\n\t\tnode.x = more_tree.x; node.y = more_tree.y;\n\t\tnode.w = more_tree.w; node.h = more_tree.h;\n\t\treturn(node);\n\t};\n\n\t/* non-recursive internal search function \n\t * [ nodes | objects ] = _search_subtree(rectangle, [return node data], [array to fill], root to begin search at)\n\t * @private\n\t */\n\tvar _search_subtree = function(rect, return_node, return_array, root) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\n\t\tif(!RTree.Rectangle.overlap_rectangle(rect, root))\n\t\t return(return_array);\n\t\n\t\tvar load_callback = function(local_tree, local_node){\n\t\t\treturn(function(data) { \n\t\t\t\tlocal_tree._attach_data(local_node, data);\n\t\t\t});\n\t\t};\n\t\n\t\thit_stack.push(root.nodes);\n\t\n\t\tdo {\n\t\t\tvar nodes = hit_stack.pop();\n\t\n\t\t\tfor(var i = nodes.length-1; i >= 0; i--) {\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t  if(RTree.Rectangle.overlap_rectangle(rect, ltree)) {\n\t\t\t  \tif(\"nodes\" in ltree) { // Not a Leaf\n\t\t\t  \t\thit_stack.push(ltree.nodes);\n\t\t\t  \t} else if(\"leaf\" in ltree) { // A Leaf !!\n\t\t\t  \t\tif(!return_node)\n\t\t  \t\t\t\treturn_array.push(ltree.leaf);\n\t\t  \t\t\telse\n\t\t  \t\t\t\treturn_array.push(ltree);\n\t\t  \t\t}/*\telse if(\"load\" in ltree) { // We need to fetch a URL for some more tree data\n\t  \t\t\t\tjQuery.getJSON(ltree.load, load_callback(this, ltree));\n\t  \t\t\t\tdelete ltree.load;\n\t  \t\t\t//\ti++; // Replay this entry\n\t  \t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn(return_array);\n\t};\n\t\n\t/* non-recursive internal insert function\n\t * [] = _insert_subtree(rectangle, object to insert, root to begin insertion at)\n\t * @private\n\t */\n\tvar _insert_subtree = function(node, root) {\n\t\tvar bc; // Best Current node\n\t\t// Initial insertion is special because we resize the Tree and we don't\n\t\t// care about any overflow (seriously, how can the first object overflow?)\n\t\tif(root.nodes.length == 0) {\n\t\t\troot.x = node.x; root.y = node.y;\n\t\t\troot.w = node.w; root.h = node.h;\n\t\t\troot.nodes.push(node);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Find the best fitting leaf node\n\t\t// choose_leaf returns an array of all tree levels (including root)\n\t\t// that were traversed while trying to find the leaf\n\t\tvar tree_stack = _choose_leaf_subtree(node, root);\n\t\tvar ret_obj = node;//{x:rect.x,y:rect.y,w:rect.w,h:rect.h, leaf:obj};\n\t\n\t\t// Walk back up the tree resizing and inserting as needed\n\t\tdo {\n\t\t\t//handle the case of an empty node (from a split)\n\t\t\tif(bc && \"nodes\" in bc && bc.nodes.length == 0) {\n\t\t\t\tvar pbc = bc; // Past bc\n\t\t\t\tbc = tree_stack.pop();\n\t\t\t\tfor(var t=0;t<bc.nodes.length;t++)\n\t\t\t\t\tif(bc.nodes[t] === pbc || bc.nodes[t].nodes.length == 0) {\n\t\t\t\t\t\tbc.nodes.splice(t, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbc = tree_stack.pop();\n\t\t\t}\n\t\t\t\n\t\t\t// If there is data attached to this ret_obj\n\t\t\tif(\"leaf\" in ret_obj || \"nodes\" in ret_obj || isArray(ret_obj)) { \n\t\t\t\t// Do Insert\n\t\t\t\tif(isArray(ret_obj)) {\n\t\t\t\t\tfor(var ai = 0; ai < ret_obj.length; ai++) {\n\t\t\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj[ai]);\n\t\t\t\t\t}\n\t\t\t\t\tbc.nodes = bc.nodes.concat(ret_obj); \n\t\t\t\t} else {\n\t\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj);\n\t\t\t\t\tbc.nodes.push(ret_obj); // Do Insert\n\t\t\t\t}\n\t\n\t\t\t\tif(bc.nodes.length <= _Max_Width)\t{ // Start Resizeing Up the Tree\n\t\t\t\t\tret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};\n\t\t\t\t}\telse { // Otherwise Split this Node\n\t\t\t\t\t// linear_split() returns an array containing two new nodes\n\t\t\t\t\t// formed from the split of the previous node's overflow\n\t\t\t\t\tvar a = _linear_split(bc.nodes);\n\t\t\t\t\tret_obj = a;//[1];\n\t\t\t\t\t\n\t\t\t\t\tif(tree_stack.length < 1)\t{ // If are splitting the root..\n\t\t\t\t\t\tbc.nodes.push(a[0]);\n\t\t\t\t\t\ttree_stack.push(bc);     // Reconsider the root element\n\t\t\t\t\t\tret_obj = a[1];\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\tdelete bc;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\telse { // Otherwise Do Resize\n\t\t\t\t//Just keep applying the new bounding rectangle to the parents..\n\t\t\t\tRTree.Rectangle.expand_rectangle(bc, ret_obj);\n\t\t\t\tret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};\n\t\t\t}\n\t\t} while(tree_stack.length > 0);\n\t};\n\n\t/* quick 'n' dirty function for plugins or manually drawing the tree\n\t * [ tree ] = RTree.get_tree(): returns the raw tree data. useful for adding\n\t * @public\n\t * !! DEPRECATED !!\n\t */\n\tthis.get_tree = function() {\n\t\treturn _T;\n\t};\n\t\n\t/* quick 'n' dirty function for plugins or manually loading the tree\n\t * [ tree ] = RTree.set_tree(sub-tree, where to attach): returns the raw tree data. useful for adding\n\t * @public\n\t * !! DEPRECATED !!\n\t */\n\tthis.set_tree = function(new_tree, where) {\n\t\tif(!where)\n\t\t\twhere = _T;\n\t\treturn(_attach_data(where, new_tree));\n\t};\n\t\n\t/* non-recursive search function \n\t * [ nodes | objects ] = RTree.search(rectangle, [return node data], [array to fill])\n\t * @public\n\t */\n\tthis.search = function(rect, return_node, return_array) {\n\t\tif(arguments.length < 1)\n\t\t\tthrow \"Wrong number of arguments. RT.Search requires at least a bounding rectangle.\"\n\n\t\tswitch(arguments.length) {\n\t\t\tcase 1:\n\t\t\t\targuments[1] = false;// Add an \"return node\" flag - may be removed in future\n\t\t\tcase 2:\n\t\t\t\targuments[2] = []; // Add an empty array to contain results\n\t\t\tcase 3:\n\t\t\t\targuments[3] = _T; // Add root node to end of argument list\n\t\t\tdefault:\n\t\t\t\targuments.length = 4;\n\t\t}\n\t\treturn(_search_subtree.apply(this, arguments));\n\t};\n\t\t\n\t/* partially-recursive toJSON function\n\t * [ string ] = RTree.toJSON([rectangle], [tree])\n\t * @public\n\t */\n\tthis.toJSON = function(rect, tree) {\n\t\tvar hit_stack = []; // Contains the elements that overlap\n\t\tvar count_stack = []; // Contains the elements that overlap\n\t\tvar return_stack = {}; // Contains the elements that overlap\n\t\tvar max_depth = 3;  // This triggers recursion and tree-splitting\n\t\tvar current_depth = 1;\n\t\tvar return_string = \"\";\n\t\t\n\t\tif(rect && !RTree.Rectangle.overlap_rectangle(rect, _T))\n\t\t return \"\";\n\t\t\n\t\tif(!tree)\t{\n\t\t\tcount_stack.push(_T.nodes.length);\n\t\t\thit_stack.push(_T.nodes);\n\t\t\treturn_string += \"var main_tree = {x:\"+_T.x.toFixed()+\",y:\"+_T.y.toFixed()+\",w:\"+_T.w.toFixed()+\",h:\"+_T.h.toFixed()+\",nodes:[\";\n\t\t}\telse {\n\t\t\tmax_depth += 4;\n\t\t\tcount_stack.push(tree.nodes.length);\n\t\t\thit_stack.push(tree.nodes);\n\t\t\treturn_string += \"var main_tree = {x:\"+tree.x.toFixed()+\",y:\"+tree.y.toFixed()+\",w:\"+tree.w.toFixed()+\",h:\"+tree.h.toFixed()+\",nodes:[\";\n\t\t}\n\t\n\t\tdo {\n\t\t\tvar nodes = hit_stack.pop();\n\t\t\tvar i = count_stack.pop()-1;\n\t\t\t\n\t\t\tif(i >= 0 && i < nodes.length-1)\n\t\t\t\treturn_string += \",\";\n\t\t\t\t\n\t\t\twhile(i >= 0)\t{\n\t\t\t\tvar ltree = nodes[i];\n\t\t\t  if(!rect || RTree.Rectangle.overlap_rectangle(rect, ltree)) {\n\t\t\t  \tif(ltree.nodes) { // Not a Leaf\n\t\t\t  \t\tif(current_depth >= max_depth) {\n\t\t\t  \t\t\tvar len = return_stack.length;\n\t\t\t  \t\t\tvar nam = _name_to_id(\"saved_subtree\");\n\t\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",load:'\"+nam+\".js'}\";\n\t\t\t  \t\t\treturn_stack[nam] = this.toJSON(rect, ltree);\n\t\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\t\treturn_string += \",\"\n\t\t\t  \t\t}\telse {\n\t\t\t\t  \t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",nodes:[\";\n\t\t\t\t  \t\tcurrent_depth += 1;\n\t\t\t\t  \t\tcount_stack.push(i);\n\t\t\t\t  \t\thit_stack.push(nodes);\n\t\t\t\t  \t\tnodes = ltree.nodes;\n\t\t\t\t  \t\ti = ltree.nodes.length;\n\t\t\t\t  \t}\n\t\t\t  \t}\telse if(ltree.leaf) { // A Leaf !!\n\t\t\t  \t\tvar data = ltree.leaf.toJSON ? ltree.leaf.toJSON() : JSON.stringify(ltree.leaf);\n\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",leaf:\" + data + \"}\";\n\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\treturn_string += \",\"\n\t\t  \t\t}\telse if(ltree.load) { // A load\n\t\t  \t\t\treturn_string += \"{x:\"+ltree.x.toFixed()+\",y:\"+ltree.y.toFixed()+\",w:\"+ltree.w.toFixed()+\",h:\"+ltree.h.toFixed()+\",load:'\" + ltree.load + \"'}\";\n\t\t\t\t\t\tif(i > 0)\n\t\t\t\t\t\t\treturn_string += \",\"\n\t\t\t  \t}\n\t\t\t\t}\n\t\t\t\ti -= 1;\n\t\t\t}\n\t\t\tif(i < 0)\t{\n\t\t\t\t\treturn_string += \"]}\"; current_depth -= 1;\n\t\t\t}\n\t\t}while(hit_stack.length > 0);\n\t\t\n\t\treturn_string+=\";\";\n\t\t\n\t\tfor(var my_key in return_stack) {\n\t\t\treturn_string += \"\\nvar \" + my_key + \" = function(){\" + return_stack[my_key] + \" return(main_tree);};\";\n\t\t}\n\t\treturn(return_string);\n\t};\n\t\n\t/* non-recursive function that deletes a specific\n\t * [ number ] = RTree.remove(rectangle, obj)\n\t */\n\tthis.remove = function(rect, obj) {\n\t\tif(arguments.length < 1)\n\t\t\tthrow \"Wrong number of arguments. RT.remove requires at least a bounding rectangle.\"\n\n\t\tswitch(arguments.length) {\n\t\t\tcase 1:\n\t\t\t\targuments[1] = false; // obj == false for conditionals\n\t\t\tcase 2:\n\t\t\t\targuments[2] = _T; // Add root node to end of argument list\n\t\t\tdefault:\n\t\t\t\targuments.length = 3;\n\t\t}\n\t\tif(arguments[1] === false) { // Do area-wide delete\n\t\t\tvar numberdeleted = 0;\n\t\t\tvar ret_array = [];\n\t\t\tdo { \n\t\t\t\tnumberdeleted=ret_array.length; \n\t\t\t\tret_array = ret_array.concat(_remove_subtree.apply(this, arguments));\n\t\t\t}while( numberdeleted !=  ret_array.length);\n\t\t\treturn ret_array;\n\t\t}\n\t\telse { // Delete a specific item\n\t\t\treturn(_remove_subtree.apply(this, arguments));\n\t\t}\n\t};\n\t\t\n\t/* non-recursive insert function\n\t * [] = RTree.insert(rectangle, object to insert)\n\t */\n\tthis.insert = function(rect, obj) {\n\t\tif(arguments.length < 2)\n\t\t\tthrow \"Wrong number of arguments. RT.Insert requires at least a bounding rectangle and an object.\"\n\t\t\n\t\treturn(_insert_subtree({x:rect.x,y:rect.y,w:rect.w,h:rect.h,leaf:obj}, _T));\n\t};\n\t\n\t/* non-recursive delete function\n\t * [deleted object] = RTree.remove(rectangle, [object to delete])\n\t */\n\n//End of RTree\n};\n\n/* Rectangle - Generic rectangle object - Not yet used */\n\nRTree.Rectangle = function(ix, iy, iw, ih) { // new Rectangle(bounds) or new Rectangle(x, y, w, h)\n    var x, x2, y, y2, w, h;\n\n    if(ix.x) {\n\t\tx = ix.x; y = ix.y;\t\n\t\t\tif(ix.w !== 0 && !ix.w && ix.x2){\n\t\t\t\tw = ix.x2-ix.x;\th = ix.y2-ix.y;\n\t\t\t}\telse {\n\t\t\t\tw = ix.w;\th = ix.h;\n\t\t\t}\n\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t} else {\n\t\tx = ix; y = iy;\tw = iw;\th = ih;\n\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t}\n\n\tthis.x1 = this.x = function(){return x;};\n\tthis.y1 = this.y = function(){return y;};\n\tthis.x2 = function(){return x2;};\n\tthis.y2 = function(){return y2;};\t\t\n\tthis.w = function(){return w;};\n\tthis.h = function(){return h;};\n\t\n\tthis.toJSON = function() {\n\t\treturn('{\"x\":'+x.toString()+', \"y\":'+y.toString()+', \"w\":'+w.toString()+', \"h\":'+h.toString()+'}');\n\t};\n\t\n\tthis.overlap = function(a) {\n\t\treturn(this.x() < a.x2() && this.x2() > a.x() && this.y() < a.y2() && this.y2() > a.y());\n\t};\n\t\n\tthis.expand = function(a) {\n\t\tvar nx = Math.min(this.x(), a.x());\n\t\tvar ny = Math.min(this.y(), a.y());\n\t\tw = Math.max(this.x2(), a.x2()) - nx;\n\t\th = Math.max(this.y2(), a.y2()) - ny;\n\t\tx = nx; y = ny;\n\t\treturn(this);\n\t};\n\t\n\tthis.setRect = function(ix, iy, iw, ih) {\n        var x, x2, y, y2, w, h;\n\t\tif(ix.x) {\n\t\t\tx = ix.x; y = ix.y;\t\n\t\t\tif(ix.w !== 0 && !ix.w && ix.x2) {\n\t\t\t\tw = ix.x2-ix.x;\th = ix.y2-ix.y;\n\t\t\t}\telse {\n\t\t\t\tw = ix.w;\th = ix.h;\n\t\t\t}\n\t\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t\t} else {\n\t\t\tx = ix; y = iy;\tw = iw;\th = ih;\n\t\t\tx2 = x + w; y2 = y + h; // For extra fastitude\n\t\t}\n\t};\n//End of RTree.Rectangle\n};\n\n\n/* returns true if rectangle 1 overlaps rectangle 2\n * [ boolean ] = overlap_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.overlap_rectangle = function(a, b) {\n\treturn(a.x < (b.x+b.w) && (a.x+a.w) > b.x && a.y < (b.y+b.h) && (a.y+a.h) > b.y);\n};\n\n/* returns true if rectangle a is contained in rectangle b\n * [ boolean ] = contains_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.contains_rectangle = function(a, b) {\n\treturn((a.x+a.w) <= (b.x+b.w) && a.x >= b.x && (a.y+a.h) <= (b.y+b.h) && a.y >= b.y);\n};\n\n/* expands rectangle A to include rectangle B, rectangle B is untouched\n * [ rectangle a ] = expand_rectangle(rectangle a, rectangle b)\n * @static function\n */\nRTree.Rectangle.expand_rectangle = function(a, b)\t{\n\tvar nx = Math.min(a.x, b.x);\n\tvar ny = Math.min(a.y, b.y);\n\ta.w = Math.max(a.x+a.w, b.x+b.w) - nx;\n\ta.h = Math.max(a.y+a.h, b.y+b.h) - ny;\n\ta.x = nx; a.y = ny;\n\treturn(a);\n};\n\n/* generates a minimally bounding rectangle for all rectangles in\n * array \"nodes\". If rect is set, it is modified into the MBR. Otherwise,\n * a new rectangle is generated and returned.\n * [ rectangle a ] = make_MBR(rectangle array nodes, rectangle rect)\n * @static function\n */\nRTree.Rectangle.make_MBR = function(nodes, rect) {\n\tif(nodes.length < 1)\n\t\treturn({x:0, y:0, w:0, h:0});\n\t\t//throw \"make_MBR: nodes must contain at least one rectangle!\";\n\tif(!rect)\n\t\trect = {x:nodes[0].x, y:nodes[0].y, w:nodes[0].w, h:nodes[0].h};\n\telse\n\t\trect.x = nodes[0].x; rect.y = nodes[0].y; rect.w = nodes[0].w; rect.h = nodes[0].h;\n\t\t\n\tfor(var i = nodes.length-1; i>0; i--)\n\t\tRTree.Rectangle.expand_rectangle(rect, nodes[i]);\n\t\t\n\treturn(rect);"],[0,"\n};"]],"start1":0,"start2":0,"length1":6864,"length2":27495}]],"length":27495,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361369978571,"patch":[[{"diffs":[[0,"})]\n\n}\n\n"],[1,"var bounds = function(arr){\n    var max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n  }\n  return a;\n};\nvar min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n  }\n  return a;\n};\nreturn [min(arr,function(v){return v[0]}),min(arr,function(v){return v[1]}),max(arr,function(v){return v[0]}),max(arr,function(v){return v[1]})];\n}\n"],[0,"//from d"]],"start1":523,"start2":523,"length1":16,"length2":1114}]],"length":28593,"saved":false}
{"ts":1361370076122,"patch":[[{"diffs":[[0,"ar bound"],[-1,"s"],[1,"Size"],[0," = funct"]],"start1":532,"start2":532,"length1":17,"length2":20},{"diffs":[[0,"eturn [m"],[-1,"in"],[1,"ax"],[0,"(arr,fun"]],"start1":1485,"start2":1485,"length1":18,"length2":18},{"diffs":[[0,"n v[0]})"],[-1,","],[1,"-"],[0,"min(arr,"]],"start1":1517,"start2":1517,"length1":17,"length2":17},{"diffs":[[0,"eturn v["],[-1,"1"],[1,"0"],[0,"]}),max("]],"start1":1547,"start2":1547,"length1":17,"length2":17},{"diffs":[[0,"v){return v["],[-1,"0]}),max"],[1,"1]})-min"],[0,"(arr,functio"]],"start1":1577,"start2":1577,"length1":32,"length2":32}]],"length":28596,"saved":false}
