{"ts":1360946759857,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n Copyright (c) 2012, Smartrak, David Leaver\n Leaflet.markercluster is an open-source JavaScript library for Marker Clustering on leaflet powered maps.\n https://github.com/danzel/Leaflet.markercluster\n*/\n(function (window, undefined) {\n\n\n/*\n * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n */\n\nL.MarkerClusterGroup = L.FeatureGroup.extend({\n\n\toptions: {\n\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\n\t\ticonCreateFunction: null,\n\n\t\tspiderfyOnMaxZoom: true,\n\t\tshowCoverageOnHover: true,\n\t\tzoomToBoundsOnClick: true,\n\t\tsingleMarkerMode: false,\n\n\t\tdisableClusteringAtZoom: null,\n\n        // Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n        // is the default behaviour for performance reasons.\n        removeOutsideVisibleBounds: true,\n\n\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\n\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n\t\tanimateAddingMarkers: false,\n\n\t\t//Increase to increase the distance away that spiderfied markers appear from the center\n\t\tspiderfyDistanceMultiplier: 1,\n\n\t\t//Options to pass to the L.Polygon constructor\n\t\tpolygonOptions: {}\n\t},\n\n\tinitialize: function (options) {\n\t\tL.Util.setOptions(this, options);\n\t\tif (!this.options.iconCreateFunction) {\n\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\n\t\t}\n\n\t\tL.FeatureGroup.prototype.initialize.call(this, []);\n\n\t\tthis._inZoomAnimation = 0;\n\t\tthis._needsClustering = [];\n\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n\t\tthis._currentShownBounds = null;\n\t},\n\n\taddLayer: function (layer) {\n\n\t\tif (layer instanceof L.LayerGroup) {\n\t\t\tvar array = [];\n\t\t\tfor (var i in layer._layers) {\n\t\t\t\tif (layer._layers.hasOwnProperty(i)) {\n\t\t\t\t\tarray.push(layer._layers[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.addLayers(array);\n\t\t}\n\n\t\tif (!this._map) {\n\t\t\tthis._needsClustering.push(layer);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\n\t\t//If we have already clustered we'll need to add this one to a cluster\n\n\t\tif (this._unspiderfy) {\n\t\t\tthis._unspiderfy();\n\t\t}\n\n\t\tthis._addLayer(layer, this._maxZoom);\n\n\t\t//Work out what is visible\n\t\tvar visibleLayer = layer,\n\t\t\tcurrentZoom = this._map.getZoom();\n\t\tif (layer.__parent) {\n\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\n\t\t\t\tvisibleLayer = visibleLayer.__parent;\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n\t\t\tif (this.options.animateAddingMarkers) {\n\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\n\t\t\t} else {\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\n\t\tif (!this._map) {\n\t\t\tthis._arraySplice(this._needsClustering, layer);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!layer.__parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this._unspiderfy) {\n\t\t\tthis._unspiderfy();\n\t\t\tthis._unspiderfyLayer(layer);\n\t\t}\n\n\t\t//Remove the marker from clusters\n\t\tthis._removeLayer(layer, true);\n\n\t\tif (layer._icon) {\n\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, layer);\n\t\t\tlayer.setOpacity(1);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Takes an array of markers and adds them in bulk\n\taddLayers: function (layersArray) {\n\t\tvar i, l, m;\n\t\tif (!this._map) {\n\t\t\tthis._needsClustering = this._needsClustering.concat(layersArray);\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\tm = layersArray[i];\n\n\t\t\tif (this.hasLayer(m)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addLayer(m, this._maxZoom);\n\n\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n\t\t\tif (m.__parent) {\n\t\t\t\tif (m.__parent.getChildCount() === 2) {\n\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\n\t\t\t\t\t\totherMarker = markers[0] === m ? markers[1] : markers[0];\n\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, otherMarker);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Update the icons of all those visible clusters that were affected\n\t\tfor (i in this._layers) {\n\t\t\tif (this._layers.hasOwnProperty(i)) {\n\t\t\t\tm = this._layers[i];\n\t\t\t\tif (m instanceof L.MarkerCluster && m._iconNeedsUpdate) {\n\t\t\t\t\tm._updateIcon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\treturn this;\n\t},\n\n\t//Takes an array of markers and removes them in bulk\n\tremoveLayers: function (layersArray) {\n\t\tvar i, l, m;\n\n\t\tif (!this._map) {\n\t\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\t\tthis._arraySplice(this._needsClustering, layersArray[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\tm = layersArray[i];\n\n\t\t\tif (!m.__parent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._removeLayer(m, true, true);\n\n\t\t\tif (m._icon) {\n\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, m);\n\t\t\t\tm.setOpacity(1);\n\t\t\t}\n\t\t}\n\n\t\t//Fix up the clusters and markers on the map\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\tfor (i in this._layers) {\n\t\t\tif (this._layers.hasOwnProperty(i)) {\n\t\t\t\tm = this._layers[i];\n\t\t\t\tif (m instanceof L.MarkerCluster) {\n\t\t\t\t\tm._updateIcon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Removes all layers from the MarkerClusterGroup\n\tclearLayers: function () {\n\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\n\n\t\t//If we aren't on the map (yet), blow away the markers we know of\n\t\tif (!this._map) {\n\t\t\tthis._needsClustering = [];\n\t\t\tdelete this._gridClusters;\n\t\t\tdelete this._gridUnclustered;\n\t\t}\n\n\t\tif (this._unspiderfy) {\n\t\t\tthis._unspiderfy();\n\t\t}\n\n\t\t//Remove all the visible layers\n\t\tfor (var i in this._layers) {\n\t\t\tif (this._layers.hasOwnProperty(i)) {\n\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, this._layers[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.eachLayer(function (marker) {\n\t\t\tdelete marker.__parent;\n\t\t});\n\n\t\tif (this._map) {\n\t\t\t//Reset _topClusterLevel and the DistanceGrids\n\t\t\tthis._generateInitialClusters();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Override FeatureGroup.getBounds as it doesn't work\n\tgetBounds: function () {\n\t\tvar bounds = new L.LatLngBounds();\n\t\tif (this._topClusterLevel) {\n\t\t\tbounds.extend(this._topClusterLevel._bounds);\n\t\t} else {\n\t\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\n\t\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t//Overrides LayerGroup.eachLayer\n\teachLayer: function (method, context) {\n\t\tvar markers = this._needsClustering.slice(),\n\t\t    i;\n\n\t\tif (this._topClusterLevel) {\n\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\n\t\t}\n\n\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\tmethod.call(context, markers[i]);\n\t\t}\n\t},\n\n\t//Returns true if the given layer is in this MarkerClusterGroup\n\thasLayer: function (layer) {\n\t\tif (this._needsClustering.length > 0) {\n\t\t\tvar anArray = this._needsClustering;\n\t\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === layer) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn !!(layer.__parent && layer.__parent._group === this);\n\t},\n\n\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n\tzoomToShowLayer: function (layer, callback) {\n\n\t\tvar showMarker = function () {\n\t\t\tif ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {\n\t\t\t\tthis._map.off('moveend', showMarker, this);\n\t\t\t\tthis.off('animationend', showMarker, this);\n\n\t\t\t\tif (layer._icon) {\n\t\t\t\t\tcallback();\n\t\t\t\t} else if (layer.__parent._icon) {\n\t\t\t\t\tvar afterSpiderfy = function () {\n\t\t\t\t\t\tthis.off('spiderfied', afterSpiderfy, this);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.on('spiderfied', afterSpiderfy, this);\n\t\t\t\t\tlayer.__parent.spiderfy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (layer._icon) {\n\t\t\tcallback();\n\t\t} else if (layer.__parent._zoom < this._map.getZoom()) {\n\t\t\t//Layer should be visible now but isn't on screen, just pan over to it\n\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\tif (!layer._icon) {\n\t\t\t\tthis._map.panTo(layer.getLatLng());\n\t\t\t}\n\t\t} else {\n\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\tthis.on('animationend', showMarker, this);\n\t\t\tthis._map.setView(layer.getLatLng(), layer.__parent._zoom + 1);\n\t\t\tlayer.__parent.zoomToBounds();\n\t\t}\n\t},\n\n\t//Overrides FeatureGroup.onAdd\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tif (!this._gridClusters) {\n\t\t\tthis._generateInitialClusters();\n\t\t}\n\n\t\tfor (var i = 0, l = this._needsClustering.length; i < l; i++) {\n\t\t\tvar layer = this._needsClustering[i];\n\t\t\tif (layer.__parent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._addLayer(layer, this._maxZoom);\n\t\t}\n\t\tthis._needsClustering = [];\n\n\t\tthis._map.on('zoomend', this._zoomEnd, this);\n\t\tthis._map.on('moveend', this._moveEnd, this);\n\n\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\tthis._spiderfierOnAdd();\n\t\t}\n\n\t\tthis._bindEvents();\n\n\n\t\t//Actually add our markers to the map:\n\n\t\t//Remember the current zoom level and bounds\n\t\tthis._zoom = this._map.getZoom();\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\n\t\t//Make things appear on the map\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t},\n\n\t//Overrides FeatureGroup.onRemove\n\tonRemove: function (map) {\n\t\tthis._map.off('zoomend', this._zoomEnd, this);\n\t\tthis._map.off('moveend', this._moveEnd, this);\n\n\t\tthis._unbindEvents();\n\n\t\t//In case we are in a cluster animation\n\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\n\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\tthis._spiderfierOnRemove();\n\t\t}\n\n\t\t//Clean up all the layers we added to the map\n\t\tfor (var i in this._layers) {\n\t\t\tif (this._layers.hasOwnProperty(i)) {\n\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, this._layers[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = null;\n\t},\n\n\n\t//Remove the given object from the given array\n\t_arraySplice: function (anArray, obj) {\n\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\tif (anArray[i] === obj) {\n\t\t\t\tanArray.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t},\n\n\t//Internal function for removing a marker from everything.\n\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\n\t\tvar gridClusters = this._gridClusters,\n\t\t\tgridUnclustered = this._gridUnclustered,\n\t\t\tmap = this._map;\n\n\t\t//Remove the marker from distance clusters it might be in\n\t\tif (removeFromDistanceGrid) {\n\t\t\tfor (var z = this._maxZoom; z >= 0; z--) {\n\t\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Work our way up the clusters removing them as we go if required\n\t\tvar cluster = marker.__parent,\n\t\t\tmarkers = cluster._markers,\n\t\t\totherMarker;\n\n\t\t//Remove the marker from the immediate parents marker list\n\t\tthis._arraySplice(markers, marker);\n\n\t\twhile (cluster) {\n\t\t\tcluster._childCount--;\n\n\t\t\tif (cluster._zoom < 0) {\n\t\t\t\t//Top level, do nothing\n\t\t\t\tbreak;\n\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\n\t\t\t\t//We need to push the other marker up to the parent\n\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n\n\t\t\t\t//Update distance grid\n\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n\n\t\t\t\t//Move otherMarker up to parent\n\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\n\t\t\t\tcluster.__parent._markers.push(otherMarker);\n\t\t\t\totherMarker.__parent = cluster.__parent;\n\n\t\t\t\tif (cluster._icon) {\n\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\n\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, cluster);\n\t\t\t\t\tif (!dontUpdateMap) {\n\t\t\t\t\t\tL.FeatureGroup.prototype.addLayer.call(this, otherMarker);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcluster._recalculateBounds();\n\t\t\t\tif (!dontUpdateMap || !cluster._icon) {\n\t\t\t\t\tcluster._updateIcon();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcluster = cluster.__parent;\n\t\t}\n\n\t\tdelete marker.__parent;\n\t},\n\n\t//Overrides FeatureGroup._propagateEvent\n\t_propagateEvent: function (e) {\n\t\tif (e.target instanceof L.MarkerCluster) {\n\t\t\te.type = 'cluster' + e.type;\n\t\t}\n\t\tL.FeatureGroup.prototype._propagateEvent.call(this, e);\n\t},\n\n\t//Default functionality\n\t_defaultIconCreateFunction: function (cluster) {\n\t\tvar childCount = cluster.getChildCount();\n\n\t\tvar c = ' marker-cluster-';\n\t\tif (childCount < 10) {\n\t\t\tc += 'small';\n\t\t} else if (childCount < 100) {\n\t\t\tc += 'medium';\n\t\t} else {\n\t\t\tc += 'large';\n\t\t}\n\n\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n\t},\n\n\t_bindEvents: function () {\n\t\tvar shownPolygon = null,\n\t\t\tmap = this._map,\n\n\t\t\tspiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick;\n\n\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\n\t\t\tthis.on('clusterclick', function (a) {\n\t\t\t\tif (map.getMaxZoom() === map.getZoom()) {\n\t\t\t\t\tif (spiderfyOnMaxZoom) {\n\t\t\t\t\t\ta.layer.spiderfy();\n\t\t\t\t\t}\n\t\t\t\t} else if (zoomToBoundsOnClick) {\n\t\t\t\t\ta.layer.zoomToBounds();\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\n\t\t//Show convex hull (boundary) polygon on mouse over\n\t\tif (showCoverageOnHover) {\n\t\t\tthis.on('clustermouseover', function (a) {\n\t\t\t\tif (this._inZoomAnimation) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (shownPolygon) {\n\t\t\t\t\tmap.removeLayer(shownPolygon);\n\t\t\t\t}\n\t\t\t\tif (a.layer.getChildCount() > 2 && a.layer !== this._spiderfied) {\n\t\t\t\t\tshownPolygon = new L.Polygon(a.layer.getConvexHull(), this.options.polygonOptions);\n\t\t\t\t\tmap.addLayer(shownPolygon);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tthis.on('clustermouseout', function () {\n\t\t\t\tif (shownPolygon) {\n\t\t\t\t\tmap.removeLayer(shownPolygon);\n\t\t\t\t\tshownPolygon = null;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tmap.on('zoomend', function () {\n\t\t\t\tif (shownPolygon) {\n\t\t\t\t\tmap.removeLayer(shownPolygon);\n\t\t\t\t\tshownPolygon = null;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tmap.on('layerremove', function (opt) {\n\t\t\t\tif (shownPolygon && opt.layer === this) {\n\t\t\t\t\tmap.removeLayer(shownPolygon);\n\t\t\t\t\tshownPolygon = null;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t},\n\n\t_unbindEvents: function () {\n\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\tmap = this._map;\n\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\n\t\t\tthis.off('clusterclick', null, this);\n\t\t}\n\t\tif (showCoverageOnHover) {\n\t\t\tthis.off('clustermouseover', null, this);\n\t\t\tthis.off('clustermouseout', null, this);\n\t\t\tmap.off('zoomend', null, this);\n\t\t\tmap.off('layerremove', null, this);\n\t\t}\n\t},\n\n\t_zoomEnd: function () {\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\treturn;\n\t\t}\n\t\tthis._mergeSplitClusters();\n\n\t\tthis._zoom = this._map._zoom;\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\t},\n\n\t_moveEnd: function () {\n\t\tif (this._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar newBounds = this._getExpandedVisibleBounds();\n\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, newBounds);\n\n\t\tthis._currentShownBounds = newBounds;\n\t\treturn;\n\t},\n\n\t_generateInitialClusters: function () {\n\t\tvar maxZoom = this._map.getMaxZoom(),\n\t\t\tradius = this.options.maxClusterRadius;\n\n\t\tif (this.options.disableClusteringAtZoom) {\n\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\n\t\t}\n\t\tthis._maxZoom = maxZoom;\n\t\tthis._gridClusters = {};\n\t\tthis._gridUnclustered = {};\n\n\t\t//Set up DistanceGrids for each zoom\n\t\tfor (var zoom = maxZoom; zoom >= 0; zoom--) {\n\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radius);\n\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radius);\n\t\t}\n\n\t\tthis._topClusterLevel = new L.MarkerCluster(this, -1);\n\t},\n\n\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n\t_addLayer: function (layer, zoom) {\n\t\tvar gridClusters = this._gridClusters,\n\t\t    gridUnclustered = this._gridUnclustered,\n\t\t    markerPoint, z;\n\n\t\tif (this.options.singleMarkerMode) {\n\t\t\tlayer.options.icon = this.options.iconCreateFunction({\n\t\t\t\tgetChildCount: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t},\n\t\t\t\tgetAllChildMarkers: function () {\n\t\t\t\t\treturn [layer];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t//Find the lowest zoom level to slot this one in\n\t\tfor (; zoom >= 0; zoom--) {\n\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n\n\t\t\t//Try find a cluster close by\n\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\n\t\t\tif (closest) {\n\t\t\t\tclosest._addChild(layer);\n\t\t\t\tlayer.__parent = closest;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Try find a marker close by to form a new cluster with\n\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\n\t\t\tif (closest) {\n\t\t\t\tvar parent = closest.__parent;\n\t\t\t\tif (parent) {\n\t\t\t\t\tthis._removeLayer(closest, false);\n\t\t\t\t}\n\n\t\t\t\t//Create new cluster with these 2 in it\n\n\t\t\t\tvar newCluster = new L.MarkerCluster(this, zoom, closest, layer);\n\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n\t\t\t\tclosest.__parent = newCluster;\n\t\t\t\tlayer.__parent = newCluster;\n\n\t\t\t\t//First create any new intermediate parent clusters that don't exist\n\t\t\t\tvar lastParent = newCluster;\n\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\n\t\t\t\t\tlastParent = new L.MarkerCluster(this, z, lastParent);\n\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n\t\t\t\t}\n\t\t\t\tparent._addChild(lastParent);\n\n\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\n\t\t\t\tfor (z = zoom; z >= 0; z--) {\n\t\t\t\t\tif (!gridUnclustered[z].removeObject(closest, this._map.project(closest.getLatLng(), z))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\n\t\t}\n\n\t\t//Didn't get in anything, add us to the top\n\t\tthis._topClusterLevel._addChild(layer);\n\t\tlayer.__parent = this._topClusterLevel;\n\t\treturn;\n\t},\n\n\t//Merge and split any existing clusters that are too big or small\n\t_mergeSplitClusters: function () {\n\t\tif (this._zoom < this._map._zoom) { //Zoom in, split\n\t\t\tthis._animationStart();\n\t\t\t//Remove clusters now off screen\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());\n\n\t\t\tthis._animationZoomIn(this._zoom, this._map._zoom);\n\n\t\t} else if (this._zoom > this._map._zoom) { //Zoom out, merge\n\t\t\tthis._animationStart();\n\n\t\t\tthis._animationZoomOut(this._zoom, this._map._zoom);\n\t\t} else {\n\t\t\tthis._moveEnd();\n\t\t}\n\t},\n\t\n\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n\t_getExpandedVisibleBounds: function () {\n        if (!this.options.removeOutsideVisibleBounds) {\n            return this.getBounds();\n        }\n\n\t\tvar map = this._map,\n\t\t\tbounds = map.getBounds(),\n\t\t\tsw = bounds._southWest,\n\t\t\tne = bounds._northEast,\n\t\t\tlatDiff = L.Browser.mobile ? 0 : Math.abs(sw.lat - ne.lat),\n\t\t\tlngDiff = L.Browser.mobile ? 0 : Math.abs(sw.lng - ne.lng);\n\n\t\treturn new L.LatLngBounds(\n\t\t\tnew L.LatLng(sw.lat - latDiff, sw.lng - lngDiff, true),\n\t\t\tnew L.LatLng(ne.lat + latDiff, ne.lng + lngDiff, true));\n\t},\n\n\t//Shared animation code\n\t_animationAddLayerNonAnimated: function (layer, newCluster) {\n\t\tif (newCluster === layer) {\n\t\t\tL.FeatureGroup.prototype.addLayer.call(this, layer);\n\t\t} else if (newCluster._childCount === 2) {\n\t\t\tnewCluster._addToMap();\n\n\t\t\tvar markers = newCluster.getAllChildMarkers();\n\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, markers[0]);\n\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, markers[1]);\n\t\t} else {\n\t\t\tnewCluster._updateIcon();\n\t\t}\n\t}\n});\n\nL.MarkerClusterGroup.include(!L.DomUtil.TRANSITION ? {\n\n\t//Non Animated versions of everything\n\t_animationStart: function () {\n\t\t//Do nothing...\n\t},\n\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationAddLayer: function (layer, newCluster) {\n\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\n\t}\n} : {\n\n\t//Animated versions here\n\t_animationStart: function () {\n\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\n\t\tthis._inZoomAnimation++;\n\t},\n\t_animationEnd: function () {\n\t\tif (this._map) {\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\t\t}\n\t\tthis._inZoomAnimation--;\n\t\tthis.fire('animationend');\n\t},\n\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\tvar me = this,\n\t\t    bounds = this._getExpandedVisibleBounds(),\n\t\t    i;\n\n\t\t//Add all children of current clusters to map and remove those clusters from map\n\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {\n\t\t\tvar startPos = c._latlng,\n\t\t\t\tmarkers = c._markers,\n\t\t\t\tm;\n\n\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\n\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(me, c);\n\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n\t\t\t} else {\n\t\t\t\t//Fade out old cluster\n\t\t\t\tc.setOpacity(0);\n\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n\t\t\t}\n\n\t\t\t//Remove all markers that aren't visible any more\n\t\t\t//TODO: Do we actually need to do this on the higher levels too?\n\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\tm = markers[i];\n\t\t\t\tif (!bounds.contains(m._latlng)) {\n\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(me, m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\tthis._forceLayout();\n\t\tvar j, n;\n\n\t\t//Update opacities\n\t\tme._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\n\t\tfor (j in me._layers) {\n\t\t\tif (me._layers.hasOwnProperty(j)) {\n\t\t\t\tn = me._layers[j];\n\n\t\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\n\t\t\t\t\tn.setOpacity(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//update the positions of the just added clusters/markers\n\t\tme._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\n\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\n\t\t});\n\n\t\t//Remove the old clusters and close the zoom animation\n\n\t\tsetTimeout(function () {\n\t\t\t//update the positions of the just added clusters/markers\n\t\t\tme._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {\n\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(me, c);\n\t\t\t\tc.setOpacity(1);\n\t\t\t});\n\n\t\t\tme._animationEnd();\n\t\t}, 250);\n\t},\n\n\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n\n\t\t//Need to add markers for those that weren't on the map before but are now\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t\t//Remove markers that were on the map before but won't be now\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\n\t\tvar bounds = this._getExpandedVisibleBounds();\n\n\t\t//Animate all of the markers in the clusters to move to their cluster center point\n\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);\n\n\t\tvar me = this;\n\n\t\t//Update the opacity (If we immediately set it they won't animate)\n\t\tthis._forceLayout();\n\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n\n\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\n\t\t//When the animations are done, tidy up\n\t\tsetTimeout(function () {\n\n\t\t\t//This cluster stopped being a cluster before the timeout fired\n\t\t\tif (cluster._childCount === 1) {\n\t\t\t\tvar m = cluster._markers[0];\n\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n\t\t\t\tm.setLatLng(m.getLatLng());\n\t\t\t\tm.setOpacity(1);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcluster._recursively(bounds, newZoomLevel, 0, function (c) {\n\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);\n\t\t\t});\n\t\t\tme._animationEnd();\n\t\t}, 250);\n\t},\n\t_animationAddLayer: function (layer, newCluster) {\n\t\tvar me = this;\n\n\t\tL.FeatureGroup.prototype.addLayer.call(this, layer);\n\t\tif (newCluster !== layer) {\n\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\n\n\t\t\t\tnewCluster._updateIcon();\n\t\t\t\tthis._forceLayout();\n\t\t\t\tthis._animationStart();\n\n\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n\t\t\t\tlayer.setOpacity(0);\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(me, layer);\n\t\t\t\t\tlayer.setOpacity(1);\n\n\t\t\t\t\tme._animationEnd();\n\t\t\t\t}, 250);\n\n\t\t\t} else { //Just became a cluster\n\t\t\t\tthis._forceLayout();\n\n\t\t\t\tme._animationStart();\n\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());\n\t\t\t}\n\t\t}\n\t},\n\n\t//Force a browser layout of stuff in the map\n\t// Should apply the current opacity and location to all elements so we can update them again for an animation\n\t_forceLayout: function () {\n\t\t//In my testing this works, infact offsetWidth of any element seems to work.\n\t\t//Could loop all this._layers and do this for each _icon if it stops working\n\n\t\tL.Util.falseFn(document.body.offsetWidth);\n\t}\n});\n\n\nL.MarkerCluster = L.Marker.extend({\n\tinitialize: function (group, zoom, a, b) {\n\n\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this });\n\n\n\t\tthis._group = group;\n\t\tthis._zoom = zoom;\n\n\t\tthis._markers = [];\n\t\tthis._childClusters = [];\n\t\tthis._childCount = 0;\n\t\tthis._iconNeedsUpdate = true;\n\n\t\tthis._bounds = new L.LatLngBounds();\n\n\t\tif (a) {\n\t\t\tthis._addChild(a);\n\t\t}\n\t\tif (b) {\n\t\t\tthis._addChild(b);\n\t\t}\n\t},\n\n\t//Recursively retrieve all child markers of this cluster\n\tgetAllChildMarkers: function (storageArray) {\n\t\tstorageArray = storageArray || [];\n\n\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\n\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray);\n\t\t}\n\n\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\n\t\t\tstorageArray.push(this._markers[j]);\n\t\t}\n\n\t\treturn storageArray;\n\t},\n\n\t//Returns the count of how many child markers we have\n\tgetChildCount: function () {\n\t\treturn this._childCount;\n\t},\n\n\t//Zoom to the extents of this cluster\n\tzoomToBounds: function () {\n\t\tthis._group._map.fitBounds(this._bounds);\n\t},\n\n\n\t_updateIcon: function () {\n\t\tthis._iconNeedsUpdate = true;\n\t\tif (this._icon) {\n\t\t\tthis.setIcon(this);\n\t\t}\n\t},\n\n\t//Cludge for Icon, we pretend to be an icon for performance\n\tcreateIcon: function () {\n\t\tif (this._iconNeedsUpdate) {\n\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\n\t\t\tthis._iconNeedsUpdate = false;\n\t\t}\n\t\treturn this._iconObj.createIcon();\n\t},\n\tcreateShadow: function () {\n\t\treturn this._iconObj.createShadow();\n\t},\n\n\n\t_addChild: function (new1, isNotificationFromChild) {\n\n\t\tthis._iconNeedsUpdate = true;\n\t\tthis._expandBounds(new1);\n\n\t\tif (new1 instanceof L.MarkerCluster) {\n\t\t\tif (!isNotificationFromChild) {\n\t\t\t\tthis._childClusters.push(new1);\n\t\t\t\tnew1.__parent = this;\n\t\t\t}\n\t\t\tthis._childCount += new1._childCount;\n\t\t} else {\n\t\t\tif (!isNotificationFromChild) {\n\t\t\t\tthis._markers.push(new1);\n\t\t\t}\n\t\t\tthis._childCount++;\n\t\t}\n\n\t\tif (this.__parent) {\n\t\t\tthis.__parent._addChild(new1, true);\n\t\t}\n\t},\n\n\t//Expand our bounds and tell our parent to\n\t_expandBounds: function (marker) {\n\t\tvar addedCount,\n\t\t    addedLatLng = marker._wLatLng || marker._latlng;\n\n\t\tif (marker instanceof L.MarkerCluster) {\n\t\t\tthis._bounds.extend(marker._bounds);\n\t\t\taddedCount = marker._childCount;\n\t\t} else {\n\t\t\tthis._bounds.extend(addedLatLng);\n\t\t\taddedCount = 1;\n\t\t}\n\n\t\tif (!this._cLatLng) {\n\t\t\t// when clustering, take position of the first point as the cluster center\n\t\t\tthis._cLatLng = marker._cLatLng || addedLatLng;\n\t\t}\n\n\t\t// when showing clusters, take weighted average of all points as cluster center\n\t\tvar totalCount = this._childCount + addedCount;\n\n\t\t//Calculate weighted latlng for display\n\t\tif (!this._wLatLng) {\n\t\t\tthis._latlng = this._wLatLng = new L.LatLng(addedLatLng.lat, addedLatLng.lng);\n\t\t} else {\n\t\t\tthis._wLatLng.lat = (addedLatLng.lat * addedCount + this._wLatLng.lat * this._childCount) / totalCount;\n\t\t\tthis._wLatLng.lng = (addedLatLng.lng * addedCount + this._wLatLng.lng * this._childCount) / totalCount;\n\t\t}\n\t},\n\n\t//Set our markers position as given and add it to the map\n\t_addToMap: function (startPos) {\n\t\tif (startPos) {\n\t\t\tthis._backupLatlng = this._latlng;\n\t\t\tthis.setLatLng(startPos);\n\t\t}\n\t\tL.FeatureGroup.prototype.addLayer.call(this._group, this);\n\t},\n\t\n\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\n\t\tthis._recursively(bounds, 0, maxZoom - 1,\n\t\t\tfunction (c) {\n\t\t\t\tvar markers = c._markers,\n\t\t\t\t\ti, m;\n\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = markers[i];\n\n\t\t\t\t\t//Only do it if the icon is still on the map\n\t\t\t\t\tif (m._icon) {\n\t\t\t\t\t\tm._setPos(center);\n\t\t\t\t\t\tm.setOpacity(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\tvar childClusters = c._childClusters,\n\t\t\t\t\tj, cm;\n\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\tcm = childClusters[j];\n\t\t\t\t\tif (cm._icon) {\n\t\t\t\t\t\tcm._setPos(center);\n\t\t\t\t\t\tcm.setOpacity(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {\n\t\tthis._recursively(bounds, newZoomLevel, 0,\n\t\t\tfunction (c) {\n\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n\n\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n\t\t\t\t\tc.setOpacity(1);\n\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n\t\t\t\t} else {\n\t\t\t\t\tc.setOpacity(0);\n\t\t\t\t}\n\n\t\t\t\tc._addToMap();\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\n\t\tthis._recursively(bounds, 0, zoomLevel, null, function (c) {\n\t\t\tc.setOpacity(1);\n\t\t});\n\t},\n\n\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\n\t\tthis._recursively(bounds, -1, zoomLevel,\n\t\t\tfunction (c) {\n\t\t\t\tif (zoomLevel === c._zoom) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Add our child markers at startPos (so they can be animated out)\n\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar nm = c._markers[i];\n\n\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (startPos) {\n\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\n\n\t\t\t\t\t\tnm.setLatLng(startPos);\n\t\t\t\t\t\tnm.setOpacity(0);\n\t\t\t\t\t}\n\n\t\t\t\t\tL.FeatureGroup.prototype.addLayer.call(c._group, nm);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\tc._addToMap(startPos);\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyRestoreChildPositions: function (zoomLevel) {\n\t\t//Fix positions of child markers\n\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\n\t\t\tvar nm = this._markers[i];\n\t\t\tif (nm._backupLatlng) {\n\t\t\t\tnm.setLatLng(nm._backupLatlng);\n\t\t\t\tdelete nm._backupLatlng;\n\t\t\t}\n\t\t}\n\n\t\tif (zoomLevel - 1 === this._zoom) {\n\t\t\t//Reposition child clusters\n\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\n\t\t\t\tthis._childClusters[j]._restorePosition();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\n\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n\t\t\t}\n\t\t}\n\t},\n\n\t_restorePosition: function () {\n\t\tif (this._backupLatlng) {\n\t\t\tthis.setLatLng(this._backupLatlng);\n\t\t\tdelete this._backupLatlng;\n\t\t}\n\t},\n\n\t//exceptBounds: If set, don't remove any markers/clusters in it\n\t_recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {\n\t\tvar m, i;\n\t\tthis._recursively(previousBounds, -1, zoomLevel - 1,\n\t\t\tfunction (c) {\n\t\t\t\t//Remove markers at every level\n\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = c._markers[i];\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(c._group, m);\n\t\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\t//Remove child clusters at just the bottom level\n\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = c._childClusters[i];\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(c._group, m);\n\t\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\n\t//Run the given functions recursively to this and child clusters\n\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n\t// zoomLevelToStart: zoom level to start running functions (inclusive)\n\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\n\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n\t\tvar childClusters = this._childClusters,\n\t\t    zoom = this._zoom,\n\t\t\ti, c;\n\n\t\tif (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters\n\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\tc = childClusters[i];\n\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { //In required depth\n\n\t\t\tif (runAtEveryLevel) {\n\t\t\t\trunAtEveryLevel(this);\n\t\t\t}\n\t\t\tif (runAtBottomLevel && this._zoom === zoomLevelToStop) {\n\t\t\t\trunAtBottomLevel(this);\n\t\t\t}\n\n\t\t\t//TODO: This loop is almost the same as above\n\t\t\tif (zoomLevelToStop > zoom) {\n\t\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tc = childClusters[i];\n\t\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_recalculateBounds: function () {\n\t\tvar markers = this._markers,\n\t\t\tchildClusters = this._childClusters,\n\t\t\ti;\n\n\t\tthis._bounds = new L.LatLngBounds();\n\t\tdelete this._wLatLng;\n\n\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\tthis._expandBounds(markers[i]);\n\t\t}\n\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\tthis._expandBounds(childClusters[i]);\n\t\t}\n\t},\n\n\n\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\n\t_isSingleParent: function () {\n\t\t//Don't need to check this._markers as the rest won't work if there are any\n\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n\t}\n});\n\n\n\nL.DistanceGrid = function (cellSize) {\n\tthis._cellSize = cellSize;\n\tthis._sqCellSize = cellSize * cellSize;\n\tthis._grid = {};\n\tthis._objectPoint = { };\n};\n\nL.DistanceGrid.prototype = {\n\n\taddObject: function (obj, point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    grid = this._grid,\n\t\t    row = grid[y] = grid[y] || {},\n\t\t    cell = row[x] = row[x] || [],\n\t\t    stamp = L.Util.stamp(obj);\n\n\t\tthis._objectPoint[stamp] = point;\n\n\t\tcell.push(obj);\n\t},\n\n\tupdateObject: function (obj, point) {\n\t\tthis.removeObject(obj);\n\t\tthis.addObject(obj, point);\n\t},\n\n\t//Returns true if the object was found\n\tremoveObject: function (obj, point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    grid = this._grid,\n\t\t    row = grid[y] = grid[y] || {},\n\t\t    cell = row[x] = row[x] || [],\n\t\t    i, len;\n\n\t\tdelete this._objectPoint[L.Util.stamp(obj)];\n\n\t\tfor (i = 0, len = cell.length; i < len; i++) {\n\t\t\tif (cell[i] === obj) {\n\n\t\t\t\tcell.splice(i, 1);\n\n\t\t\t\tif (len === 1) {\n\t\t\t\t\tdelete row[x];\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t},\n\n\teachObject: function (fn, context) {\n\t\tvar i, j, k, len, row, cell, removed,\n\t\t    grid = this._grid;\n\n\t\tfor (i in grid) {\n\t\t\tif (grid.hasOwnProperty(i)) {\n\t\t\t\trow = grid[i];\n\n\t\t\t\tfor (j in row) {\n\t\t\t\t\tif (row.hasOwnProperty(j)) {\n\t\t\t\t\t\tcell = row[j];\n\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\n\t\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\t\tk--;\n\t\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tgetNearObject: function (point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    i, j, k, row, cell, len, obj, dist,\n\t\t    objectPoint = this._objectPoint,\n\t\t    closestDistSq = this._sqCellSize,\n\t\t    closest = null;\n\n\t\tfor (i = y - 1; i <= y + 1; i++) {\n\t\t\trow = this._grid[i];\n\t\t\tif (row) {\n\n\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\n\t\t\t\t\tcell = row[j];\n\t\t\t\t\tif (cell) {\n\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\tobj = cell[k];\n\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n\t\t\t\t\t\t\tif (dist < closestDistSq) {\n\t\t\t\t\t\t\t\tclosestDistSq = dist;\n\t\t\t\t\t\t\t\tclosest = obj;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn closest;\n\t},\n\n\t_getCoord: function (x) {\n\t\treturn Math.floor(x / this._cellSize);\n\t},\n\n\t_sqDist: function (p, p2) {\n\t\tvar dx = p2.x - p.x,\n\t\t    dy = p2.y - p.y;\n\t\treturn dx * dx + dy * dy;\n\t}\n};\n\n\n/* Copyright (c) 2012 the authors listed at the following URL, and/or\nthe authors of referenced articles or incorporated external code:\nhttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n*/\n\n(function () {\n\tL.QuickHull = {\n\t\tgetDistant: function (cpt, bl) {\n\t\t\tvar vY = bl[1].lat - bl[0].lat,\n\t\t\t\tvX = bl[0].lng - bl[1].lng;\n\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\n\t\t},\n\n\n\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\n\t\t\tvar maxD = 0,\n\t\t\t\tmaxPt = null,\n\t\t\t\tnewPoints = [],\n\t\t\t\ti, pt, d;\n\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\tpt = latLngs[i];\n\t\t\t\td = this.getDistant(pt, baseLine);\n\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tnewPoints.push(pt);\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (d > maxD) {\n\t\t\t\t\tmaxD = d;\n\t\t\t\t\tmaxPt = pt;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn { 'maxPoint': maxPt, 'newPoints': newPoints };\n\t\t},\n\n\t\tbuildConvexHull: function (baseLine, latLngs) {\n\t\t\tvar convexHullBaseLines = [],\n\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n\n\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\n\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\n\t\t\t\t\t);\n\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\n\t\t\t\t\t);\n\t\t\t\treturn convexHullBaseLines;\n\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\n\t\t\t\treturn [baseLine];\n\t\t\t}\n\t\t},\n\n\t\tgetConvexHull: function (latLngs) {\n\t\t\t//find first baseline\n\t\t\tvar maxLat = false, minLat = false,\n\t\t\t\tmaxPt = null, minPt = null,\n\t\t\t\ti;\n\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\tvar pt = latLngs[i];\n\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\n\t\t\t\t\tmaxPt = pt;\n\t\t\t\t\tmaxLat = pt.lat;\n\t\t\t\t}\n\t\t\t\tif (minLat === false || pt.lat < minLat) {\n\t\t\t\t\tminPt = pt;\n\t\t\t\t\tminLat = pt.lat;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\n\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\n\t\t\treturn ch;\n\t\t}\n\t};\n}());\n\nL.MarkerCluster.include({\n\tgetConvexHull: function () {\n\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\tpoints = [],\n\t\t\thullLatLng = [],\n\t\t\thull, p, i;\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tp = childMarkers[i].getLatLng();\n\t\t\tpoints.push(p);\n\t\t}\n\n\t\thull = L.QuickHull.getConvexHull(points);\n\n\t\tfor (i = hull.length - 1; i >= 0; i--) {\n\t\t\thullLatLng.push(hull[i][0]);\n\t\t}\n\n\t\treturn hullLatLng;\n\t}\n});\n\n//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n//Huge thanks to jawj for implementing it first to make my job easy :-)\n\nL.MarkerCluster.include({\n\n\t_2PI: Math.PI * 2,\n\t_circleFootSeparation: 25, //related to circumference of circle\n\t_circleStartAngle: Math.PI / 6,\n\n\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\n\t_spiralLengthStart: 11,\n\t_spiralLengthFactor: 5,\n\n\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\n\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\n\n\tspiderfy: function () {\n\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\tgroup = this._group,\n\t\t\tmap = group._map,\n\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\n\t\t\tpositions;\n\n\t\tthis._group._unspiderfy();\n\t\tthis._group._spiderfied = this;\n\n\t\t//TODO Maybe: childMarkers order by distance to center\n\n\t\tif (childMarkers.length >= this._circleSpiralSwitchover) {\n\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\n\t\t} else {\n\t\t\tcenter.y += 10; //Otherwise circles look wrong\n\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\n\t\t}\n\n\t\tthis._animationSpiderfy(childMarkers, positions);\n\t},\n\n\tunspiderfy: function (zoomDetails) {\n\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n\t\tif (this._group._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\t\tthis._animationUnspiderfy(zoomDetails);\n\n\t\tthis._group._spiderfied = null;\n\t},\n\n\t_generatePointsCircle: function (count, centerPt) {\n\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\n\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\n\t\t\tangleStep = this._2PI / count,\n\t\t\tres = [],\n\t\t\ti, angle;\n\n\t\tres.length = count;\n\n\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\tangle = this._circleStartAngle + i * angleStep;\n\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t}\n\n\t\treturn res;\n\t},\n\n\t_generatePointsSpiral: function (count, centerPt) {\n\t\tvar legLength = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart,\n\t\t\tseparation = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation,\n\t\t\tlengthFactor = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor,\n\t\t\tangle = 0,\n\t\t\tres = [],\n\t\t\ti;\n\n\t\tres.length = count;\n\n\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\tangle += separation / legLength + i * 0.0005;\n\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\tlegLength += this._2PI * lengthFactor / angle;\n\t\t}\n\t\treturn res;\n\t}\n});\n\nL.MarkerCluster.include(!L.DomUtil.TRANSITION ? {\n\t//Non Animated versions of everything\n\t_animationSpiderfy: function (childMarkers, positions) {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\ti, m, leg, newPos;\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\tm = childMarkers[i];\n\n\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\tm.setLatLng(newPos);\n\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\n\t\t\tL.FeatureGroup.prototype.addLayer.call(group, m);\n\n\n\t\t\tleg = new L.Polyline([this._latlng, newPos], { weight: 1.5, color: '#222' });\n\t\t\tmap.addLayer(leg);\n\t\t\tm._spiderLeg = leg;\n\t\t}\n\t\tthis.setOpacity(0.3);\n\t\tgroup.fire('spiderfied');\n\t},\n\n\t_animationUnspiderfy: function () {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\tchildMarkers = this.getAllChildMarkers(),\n\t\t\tm, i;\n\n\t\tthis.setOpacity(1);\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\tL.FeatureGroup.prototype.removeLayer.call(group, m);\n\n\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\tm.setZIndexOffset(0);\n\n\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\tdelete m._spiderLeg;\n\t\t}\n\t}\n} : {\n\t//Animated versions here\n\tSVG_ANIMATION: (function () {\n\t\treturn document.createElementNS('http://www.w3.org/2000/svg', 'animate').toString().indexOf('SVGAnimate') > -1;\n\t}()),\n\n\t_animationSpiderfy: function (childMarkers, positions) {\n\t\tvar me = this,\n\t\t\tgroup = this._group,\n\t\t\tmap = group._map,\n\t\t\tthisLayerPos = map.latLngToLayerPoint(this._latlng),\n\t\t\ti, m, leg, newPos;\n\n\t\t//Add markers to map hidden at our center point\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\tm.setOpacity(0);\n\n\t\t\tL.FeatureGroup.prototype.addLayer.call(group, m);\n\n\t\t\tm._setPos(thisLayerPos);\n\t\t}\n\n\t\tgroup._forceLayout();\n\t\tgroup._animationStart();\n\n\t\tvar initialLegOpacity = L.Path.SVG ? 0 : 0.3,\n\t\t\txmlns = L.Path.SVG_NS;\n\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\tm = childMarkers[i];\n\n\t\t\t//Move marker to new position\n\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\tm.setLatLng(newPos);\n\t\t\tm.setOpacity(1);\n\n\n\t\t\t//Add Legs.\n\t\t\tleg = new L.Polyline([me._latlng, newPos], { weight: 1.5, color: '#222', opacity: initialLegOpacity });\n\t\t\tmap.addLayer(leg);\n\t\t\tm._spiderLeg = leg;\n\n\t\t\t//Following animations don't work for canvas\n\t\t\tif (!L.Path.SVG || !this.SVG_ANIMATION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//How this works:\n\t\t\t//http://stackoverflow.com/questions/5924238/how-do-you-animate-an-svg-path-in-ios\n\t\t\t//http://dev.opera.com/articles/view/advanced-svg-animation-techniques/\n\n\t\t\t//Animate length\n\t\t\tvar length = leg._path.getTotalLength();\n\t\t\tleg._path.setAttribute(\"stroke-dasharray\", length + \",\" + length);\n\n\t\t\tvar anim = document.createElementNS(xmlns, \"animate\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-dashoffset\");\n\t\t\tanim.setAttribute(\"begin\", \"indefinite\");\n\t\t\tanim.setAttribute(\"from\", length);\n\t\t\tanim.setAttribute(\"to\", 0);\n\t\t\tanim.setAttribute(\"dur\", 0.25);\n\t\t\tleg._path.appendChild(anim);\n\t\t\tanim.beginElement();\n\n\t\t\t//Animate opacity\n\t\t\tanim = document.createElementNS(xmlns, \"animate\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-opacity\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-opacity\");\n\t\t\tanim.setAttribute(\"begin\", \"indefinite\");\n\t\t\tanim.setAttribute(\"from\", 0);\n\t\t\tanim.setAttribute(\"to\", 0.5);\n\t\t\tanim.setAttribute(\"dur\", 0.25);\n\t\t\tleg._path.appendChild(anim);\n\t\t\tanim.beginElement();\n\t\t}\n\t\tme.setOpacity(0.3);\n\n\t\t//Set the opacity of the spiderLegs back to their correct value\n\t\t// The animations above override this until they complete.\n\t\t// If the initial opacity of the spiderlegs isn't 0 then they appear before the animation starts.\n\t\tif (L.Path.SVG) {\n\t\t\tthis._group._forceLayout();\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i]._spiderLeg;\n\n\t\t\t\tm.options.opacity = 0.5;\n\t\t\t\tm._path.setAttribute('stroke-opacity', 0.5);\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(function () {\n\t\t\tgroup._animationEnd();\n\t\t\tgroup.fire('spiderfied');\n\t\t}, 250);\n\t},\n\n\t_animationUnspiderfy: function (zoomDetails) {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\n\t\t\tchildMarkers = this.getAllChildMarkers(),\n\t\t\tsvg = L.Path.SVG && this.SVG_ANIMATION,\n\t\t\tm, i, a;\n\n\t\tgroup._animationStart();\n\t\t\n\t\t//Make us visible and bring the child markers back in\n\t\tthis.setOpacity(1);\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\t//Marker was added to us after we were spidified\n\t\t\tif (!m._preSpiderfyLatlng) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Fix up the location to the real one\n\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t//Hack override the location to be our center\n\t\t\tm._setPos(thisLayerPos);\n\n\t\t\tm.setOpacity(0);\n\n\t\t\t//Animate the spider legs back in\n\t\t\tif (svg) {\n\t\t\t\ta = m._spiderLeg._path.childNodes[0];\n\t\t\t\ta.setAttribute('to', a.getAttribute('from'));\n\t\t\t\ta.setAttribute('from', 0);\n\t\t\t\ta.beginElement();\n\n\t\t\t\ta = m._spiderLeg._path.childNodes[1];\n\t\t\t\ta.setAttribute('from', 0.5);\n\t\t\t\ta.setAttribute('to', 0);\n\t\t\t\ta.setAttribute('stroke-opacity', 0);\n\t\t\t\ta.beginElement();\n\n\t\t\t\tm._spiderLeg._path.setAttribute('stroke-opacity', 0);\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(function () {\n\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\n\t\t\tvar stillThereChildCount = 0;\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\tstillThereChildCount++;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\tm.setOpacity(1);\n\t\t\t\tm.setZIndexOffset(0);\n\n\t\t\t\tif (stillThereChildCount > 1) {\n\t\t\t\t\tL.FeatureGroup.prototype.removeLayer.call(group, m);\n\t\t\t\t}\n\n\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\tdelete m._spiderLeg;\n\t\t\t}\n\t\t\tgroup._animationEnd();\n\t\t}, 250);\n\t}\n});\n\n\nL.MarkerClusterGroup.include({\n\t//The MarkerCluster currently spiderfied (if any)\n\t_spiderfied: null,\n\n\t_spiderfierOnAdd: function () {\n\t\tthis._map.on('click', this._unspiderfyWrapper, this);\n\n\t\tif (this._map.options.zoomAnimation) {\n\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\n\t\t} else {\n\t\t\t//Browsers without zoomAnimation don't fire zoomstart\n\t\t\tthis._map.on('zoomend', this._unspiderfyWrapper, this);\n\t\t}\n\n\t\tif (L.Path.SVG && !L.Browser.touch) {\n\t\t\tthis._map._initPathRoot();\n\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\n\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n\t\t}\n\t},\n\n\t_spiderfierOnRemove: function () {\n\t\tthis._map.off('click', this._unspiderfyWrapper, this);\n\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\n\t\tthis._unspiderfy(); //Ensure that markers are back where they should be\n\t},\n\n\n\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\n\t_unspiderfyZoomStart: function () {\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\treturn;\n\t\t}\n\n\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\n\t},\n\t_unspiderfyZoomAnim: function (zoomDetails) {\n\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\tthis._unspiderfy(zoomDetails);\n\t},\n\n\n\t_unspiderfyWrapper: function () {\n\t\t/// <summary>_unspiderfy but passes no arguments</summary>\n\t\tthis._unspiderfy();\n\t},\n\n\t_unspiderfy: function (zoomDetails) {\n\t\tif (this._spiderfied) {\n\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\n\t\t}\n\t},\n\n\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n\t_unspiderfyLayer: function (layer) {\n\t\tif (layer._spiderLeg) {\n\t\t\tL.FeatureGroup.prototype.removeLayer.call(this, layer);\n\n\t\t\tlayer.setOpacity(1);\n\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\n\t\t\tlayer.setZIndexOffset(0);\n\n\t\t\tthis._map.removeLayer(layer._spiderLeg);\n\t\t\tdelete layer._spiderLeg;\n\t\t}\n\t}\n});\n\n\n\n}(this));"]],"start1":0,"start2":0,"length1":0,"length2":53140}]],"length":53140}
